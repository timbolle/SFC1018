[
  {
    "objectID": "SFC1018_Traitement_R.html",
    "href": "SFC1018_Traitement_R.html",
    "title": "Traitement de données avec R",
    "section": "",
    "text": "Le terme tidyverse est une contraction de tidy (qu’on pourrait traduire par “bien rangé”) et de universe. Il s’agit en fait d’une collection d’extensions conçues pour travailler ensemble et basées sur une philosophie commune.\nElles abordent un très grand nombre d’opérations courantes dans R (la liste n’est pas exhaustive) :\n\nvisualisation\nmanipulation des tableaux de données\nimport/export de données\nmanipulation de variables\nextraction de données du Web\nprogrammation\n\nUn des objectifs de ces extensions est de fournir des fonctions avec une syntaxe cohérente, qui fonctionnent bien ensemble, et qui retournent des résultats prévisibles. Elles sont en grande partie issues du travail d’Hadley Wickham, qui travaille désormais pour RStudio.\n\n\ntidyverse est également le nom d’une extension qu’on peut installer de manière classique, soit via le bouton Install de l’onglet Packages de RStudio, soit en utilisant la commande :\n\ninstall.packages(\"tidyverse\")\n\n\n\n\n\n\n\nNote\n\n\n\nNormalement vous devriez déjà avoir fait cette installation lors de la partie précédente.\n\n\nCette commande va en fait installer plusieurs extensions qui constituent le “coeur” du tidyverse, à savoir :\n\nggplot2 (visualisation)\ndplyr (manipulation des données)\ntidyr (remise en forme des données)\npurrr (programmation)\nreadr (importation de données)\ntibble (tableaux de données)\nforcats (variables qualitatives)\nstringr (chaînes de caractères)\nlubridate (manipulation de dates)\n\n\n\n\nPackages de l’extension tidyverse\n\n\nDe la même manière, charger l’extension avec :\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nChargera l’ensemble des extensions précédentes. Elles peuvent également être chargées indépendamment.\nIl existe d’autres extensions qui font partie du tidyverse mais qui doivent être chargées explicitement, comme par exemple readxl (pour l’importation de données depuis des fichiers Excel). La liste complète se trouve sur le site officiel du tidyverse."
  },
  {
    "objectID": "SFC1018_Traitement_R.html#installation",
    "href": "SFC1018_Traitement_R.html#installation",
    "title": "Traitement de données avec R",
    "section": "",
    "text": "tidyverse est également le nom d’une extension qu’on peut installer de manière classique, soit via le bouton Install de l’onglet Packages de RStudio, soit en utilisant la commande :\n\ninstall.packages(\"tidyverse\")\n\n\n\n\n\n\n\nNote\n\n\n\nNormalement vous devriez déjà avoir fait cette installation lors de la partie précédente.\n\n\nCette commande va en fait installer plusieurs extensions qui constituent le “coeur” du tidyverse, à savoir :\n\nggplot2 (visualisation)\ndplyr (manipulation des données)\ntidyr (remise en forme des données)\npurrr (programmation)\nreadr (importation de données)\ntibble (tableaux de données)\nforcats (variables qualitatives)\nstringr (chaînes de caractères)\nlubridate (manipulation de dates)\n\n\n\n\nPackages de l’extension tidyverse\n\n\nDe la même manière, charger l’extension avec :\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nChargera l’ensemble des extensions précédentes. Elles peuvent également être chargées indépendamment.\nIl existe d’autres extensions qui font partie du tidyverse mais qui doivent être chargées explicitement, comme par exemple readxl (pour l’importation de données depuis des fichiers Excel). La liste complète se trouve sur le site officiel du tidyverse."
  },
  {
    "objectID": "SFC1018_Traitement_R.html#import-de-fichiers-textes",
    "href": "SFC1018_Traitement_R.html#import-de-fichiers-textes",
    "title": "Traitement de données avec R",
    "section": "2.1 Import de fichiers textes",
    "text": "2.1 Import de fichiers textes\nL’extension readr, qui fait partie du tidyverse, permet l’importation de fichiers texte, notamment au format CSV (Comma separated values), format standard pour l’échange de données tabulaires entre logiciels.\nCette extension fait partie du “coeur” du tidyverse, elle est donc automatiquement chargée avec :\n\nlibrary(tidyverse)\n\nSi votre fichier CSV suit un format CSV standard (c’est le cas s’il a été exporté depuis LibreOffice par exemple), avec des champs séparés par des virgules, vous pouvez utiliser la fonction read_csv en lui passant en argument le nom du fichier :\n\nd &lt;- read_csv(\"fichier.csv\")\n\n\n\n\n\n\n\nNote\n\n\n\nIci, nous avons indiquer un nom de fichier générique qui n’est pas fournit. Ici, le fichier StarWars_Characters.csv a été placé dans un dossier data qui se trouve dans le même dossier que votre script R !\n\n\nSi votre fichier vient d’Excel, avec des valeurs séparées par des points virgule, utilisez la fonction read_csv2 :\n\nd &lt;- read_csv2(\"fichier.csv\")\n\nDans la même famille de fonction, read_tsv permet d’importer des fichiers dont les valeurs sont séparées par des tabulations, et read_delim des fichiers délimités par un séparateur indiqué en argument.\nChaque fonction dispose de plusieurs arguments, parmi lesquels :\n\ncol_names indique si la première ligne contient le nom des colonnes (TRUE par défaut)\ncol_types permet de spécifier manuellement le type des colonnes si readr ne les identifie pas correctement\nna est un vecteur de chaînes de caractères indiquant les valeurs devant être considérées comme manquantes. Ce vecteur vaut c(\"\", \"NA\") par défaut\n\nIl peut arriver, notamment sous Windows, que l’encodage des caractères accentués ne soit pas correct au moment de l’importation. On peut alors spécifier manuellement l’encodage du fichier importé à l’aide de l’option locale. Par exemple, si l’on est sous Mac ou Linux et que le fichier a été créé sous Windows, il est possible qu’il soit encodé au format iso-8859-1. On peut alors l’importer avec :\n\nd &lt;- read_csv(\"fichier.csv\", locale = locale(encoding = \"ISO-8859-1\"))\n\nÀ l’inverse, si vous importez un fichier sous Windows et que les accents ne sont pas affichés correctement, il est sans doute encodé en UTF-8 :\n\nd &lt;- read_csv(\"fichier.csv\", locale = locale(encoding = \"UTF-8\"))\n\nPour plus d’informations sur ces fonctions, voir le site de l’extension readr.\n\n\n\n\n\n\nNote\n\n\n\nÀ noter que si vous souhaitez importer des fichiers textes très volumineux le plus rapidement possible, la fonction fread de l’extension data.table est plus rapide que read_csv."
  },
  {
    "objectID": "SFC1018_Traitement_R.html#import-depuis-un-fichier-excel",
    "href": "SFC1018_Traitement_R.html#import-depuis-un-fichier-excel",
    "title": "Traitement de données avec R",
    "section": "2.2 Import depuis un fichier Excel",
    "text": "2.2 Import depuis un fichier Excel\nL’extension readxl, qui fait également partie du tidyverse, permet d’importer des données directement depuis un fichier au format xlsou xlsx.\nElle ne fait pas partie du “coeur” du tidyverse, il faut donc la charger explicitement avec :\n\nlibrary(readxl)\n\nOn peut alors utiliser la fonction read_excel en lui spécifiant le nom du fichier :\n\nd &lt;- read_excel(\"fichier.xls\")\n\nIl est possible de spécifier la feuille et la plage de cellules que l’on souhaite importer avec les arguments sheet et range :\n\nd &lt;- read_excel(\"fichier.xls\", sheet = \"Feuille2\", range = \"C1:F124\")\n\nPour plus d’informations, voir le site de l’extension readxl."
  },
  {
    "objectID": "SFC1018_Traitement_R.html#exercice-1",
    "href": "SFC1018_Traitement_R.html#exercice-1",
    "title": "Traitement de données avec R",
    "section": "2.3 Exercice 1",
    "text": "2.3 Exercice 1\nImportez les données présentes dans les fichiers StarWars_characters.csv et celles présentes dans la feuille character du fichier StarWars.xlsx"
  },
  {
    "objectID": "SFC1018_Traitement_R.html#sec-vecteurs",
    "href": "SFC1018_Traitement_R.html#sec-vecteurs",
    "title": "Traitement de données avec R",
    "section": "4.1 Rappel sur les variables et les vecteurs",
    "text": "4.1 Rappel sur les variables et les vecteurs\nDans R, une variable, en général une colonne d’un tableau de données, est un objet de type vecteur. Un vecteur est un ensemble d’éléments, tous du même type.\nOn a vu qu’on peut construire un vecteur manuellement de différentes manières :\n\ncouleur &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nnombres &lt;- 1:10\n\nMais le plus souvent on manipule des vecteurs faisant partie d’une table importée dans R.\nPour la suite, nous allons utiliser le jeux de données Star Wars et essayer de faire un peu de nettoyage !\n\nsw &lt;- read.csv(\"data/StarWars_characters.csv\")\n\nQuand on veut accéder à un vecteur d’un tableau de données, on peut utiliser l’opérateur $ :\n\nsw$name\n\nLes vecteurs peuvent être de classes différentes, selon le type de données qu’ils contiennent.\nOn a ainsi des vecteurs de type integer ou double, qui contiennent respectivement des nombres entiers ou décimaux. Dans notre exemple, nous avons simplement une colonne de type integer :\n\ntypeof(sw$height)\n\n[1] \"integer\"\n\n\nDes vecteurs de type character, qui contiennent des chaînes de caractères :\n\ntypeof(sw$name)\nhead(sw$name)\n\nEt des vecteurs de type logical, qui ne peuvent contenir que les valeurs vraie (TRUE) ou fausse (FALSE).\n\nvec &lt;- c(TRUE, FALSE, FALSE, TRUE)\ntypeof(vec)\n\n[1] \"logical\"\n\n\nOn peut convertir un vecteur d’un type en un autre en utilisant les fonctions as.numeric, as.character ou as.logical. Les valeurs qui n’ont pas pu être converties sont automatiquement transformées en NA.\n\nx &lt;- c(\"1\", \"2.35\", \"8.2e+03\", \"foo\")\nas.numeric(x)\n\nWarning: NAs introduits lors de la conversion automatique\n\n\n[1]    1.00    2.35 8200.00      NA\n\ny &lt;- 2:6\nas.character(y)\n\n[1] \"2\" \"3\" \"4\" \"5\" \"6\"\n\n\nDans nos données, nous voyons que la colonne mass a été importée comme étant de type character alors qu’il s’agit de nombre. Cela vient probablement du fait qu’un des nombre est mal formaté. La fonction as.numeric affiche normalement un warning lorsque qu’un élément n’a pas pu être converti.\n\nas.numeric(sw$mass)\n\nWarning: NAs introduits lors de la conversion automatique\n\n\n [1]  77.0  75.0  32.0 136.0  49.0 120.0  75.0  32.0  84.0  77.0  84.0    NA\n[13] 112.0  80.0  74.0    NA  77.0 110.0  17.0  75.0  78.2 140.0 113.0  79.0\n[25]  79.0  83.0    NA    NA  20.0  68.0  89.0  90.0    NA  66.0  82.0    NA\n[37]    NA    NA  40.0    NA    NA  80.0    NA  55.0  45.0    NA  65.0  84.0\n[49]  82.0  87.0    NA  50.0    NA    NA  80.0    NA  85.0    NA    NA  80.0\n[61]  56.2  50.0    NA  80.0    NA  79.0  55.0 102.0  88.0    NA    NA  15.0\n[73]    NA  48.0    NA  57.0 159.0 136.0  79.0  48.0  80.0    NA    NA    NA\n[85]    NA    NA  45.0\n\n\nEn allant jeter un coup d’oeil dans les données, nous voyons que la masse pour Jabba Desilijic Tiure comporte une vigule à la place d’un point pour séparer les décimales3. Nous pouvons faire un remplacement des virgules en points pour cette colonne avec la fonction gsub:\n\nsw$mass &lt;- gsub(\",\", \".\", sw$mass)\n\nNous pouvons maintenant faire notre conversion de type:\n\nsw$mass &lt;- as.numeric(sw$mass)"
  },
  {
    "objectID": "SFC1018_Traitement_R.html#sec-tests",
    "href": "SFC1018_Traitement_R.html#sec-tests",
    "title": "Traitement de données avec R",
    "section": "4.2 Tests et comparaison",
    "text": "4.2 Tests et comparaison\nUn test est une opération logique de comparaison qui renvoie vrai (TRUE) ou faux (FALSE) pour chacun des éléments d’un vecteur.\nParmi les opérateurs de comparaison disponibles, on trouve notamment :\n\n== qui teste l’égalité\n!= qui teste la différence\n&gt;, &lt;, &lt;=, &gt;= qui testent la supériorité ou l’infériorité\n%in% qui teste l’appartenance à un ensemble de valeurs\n\nExemple le plus simple :\n\n2 == 3\n\n[1] FALSE\n\n\n\n2 != 3\n\n[1] TRUE\n\n\nExemple appliqué à un vecteur :\n\nx &lt;- 1:10\nx &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nOn peut combiner plusieurs tests avec les opérateurs logiques et (&) et ou (|). Ainsi, si on veut tester qu’une valeur est comprise entre 3 et 6 inclus, on peut faire :\n\nx &gt;= 3 & x &lt;= 6\n\n [1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\nSi on veut tester qu’une valeur est égale à “Bleu” ou à “Vert”, on peut faire :\n\nvec &lt;- c(\"Jaune\", \"Jaune\", \"Rouge\", \"Vert\")\nvec == \"Jaune\" | vec == \"Vert\"\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n\nÀ noter que dans ce cas, on peut utiliser l’opérateur %in%4, qui teste si une valeur fait partie des éléments d’un vecteur :\n\nvec %in% c(\"Jaune\", \"Vert\")\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention, si on souhaite tester si une valeur x est inconnue (ou ‘manquante’), c’est-à-dire si elle est codée NA (Not Available), faire le test x == NA ne donnera pas le résultat escompté. En effet, fidèle à sa réputation de rigueur informaticienne, pour R NA == NA ne vaut pas TRUE mais… NA (on ne sait pas si une valeur inconnue est égale à une autre valeur inconnue).\nPour tester si une valeur est inconnue (NA), il faut utiliser la fonction dédiée is.na et faire is.na(x).\nCependant, par convention, NA %in% NA vaut TRUE.\n\n\nEnfin, on peut inverser un test avec l’opérateur non (!) :\n\n!(vec %in% c(\"Jaune\", \"Vert\"))\n\n[1] FALSE FALSE  TRUE FALSE\n\n\nLes tests sont notamment utilisés par le verbe filter de dplyr (que nous verrons plus loin) qui permet de sélectionner certaines lignes d’un tableau de données. On peut ainsi sélectionner les personnages de plus de 1 mètre :\n\nfilter(sw, height &gt;= 100)\n\nOu sélectionner les personnages ayant comme homeworld Tatooine ou Naboo :\n\nfilter(sw, homeworld %in% c(\"Tatooine\", \"Naboo\"))\n\nOn peut utiliser les tests pour sélectionner certains éléments d’un vecteur. Si on passe un test à l’opérateur de sélection [], seuls les éléments pour lesquels ce test est vrai seront conservés :\n\nx &lt;- c(12, 8, 14, 7, 6, 18)\nx[x &gt; 10]\n\n[1] 12 14 18\n\n\nEnfin, on peut aussi utiliser les tests et la sélection pour modifier les valeurs d’un vecteur. Ainsi, si on assigne une valeur à une sélection, les éléments pour lesquels le test est vrai sont remplacés par cette valeur :\n\nx &lt;- c(12, 8, 14, 7, 6, 18)\nx[x &gt; 10] &lt;- 100\nx\n\n[1] 100   8 100   7   6 100\n\n\nEn utilisant cette assignation via un test, on peut effectuer des recodages de variables. Soit le vecteur suivant :\n\nvec &lt;- c(\"Femme\", \"Homme\", \"Femme\", \"Garçon\")\n\nSi on souhaite recoder la modalité “Garçon” en “Homme”, on peut utiliser la syntaxe suivante :\n\nvec[vec == \"Garçon\"] &lt;- \"Homme\"\nvec\n\n[1] \"Femme\" \"Homme\" \"Femme\" \"Homme\"\n\n\nCette syntaxe est tout à fait valable et couramment utilisée. On va cependant voir dans la section suivante différentes fonctions qui facilitent ces opérations de recodage.\nDans notre exemple, si nous regardons la colonne gender, nous voyons une valeur \"none\" qui n’a pas été comptée comme NA. D’ailleurs, tous les NA sont en faite des droids. Nous allons donc changer les NA et les \"none\" en \"droid\":\n\nsw$gender[sw$gender == \"none\" | is.na(sw$gender)] &lt;- \"droid\""
  },
  {
    "objectID": "SFC1018_Traitement_R.html#sec-recoder-une-variable-qualitative",
    "href": "SFC1018_Traitement_R.html#sec-recoder-une-variable-qualitative",
    "title": "Traitement de données avec R",
    "section": "4.3 Recoder une variable qualitative",
    "text": "4.3 Recoder une variable qualitative\nPour rappel, on appelle variable qualitative une variable pouvant prendre un nombre limité de modalités (de valeurs possibles).\n\n4.3.1 Facteurs et forcats\nDans R, les variables qualitatives peuvent être de deux types : ou bien des vecteurs de type character (des chaînes de caractères), ou bien des factor (facteurs). Si vous utilisez les fonctions des extensions du tidyverse comme readr, readxl ou haven pour importer vos données, vos variables qualitatives seront importées sous forme de character. Mais dans d’autres cas elles se retrouveront parfois sous forme de factor.\nPour convertir une colonne en factors, nous pouvons utiliser la fonction as_factor:\n\nsw$gender &lt;- as_factor(sw$gender)\n\nLes facteurs sont un type de variable ne pouvant prendre qu’un nombre défini de modalités nommés levels.\n\nlevels(sw$gender)\n\n[1] \"male\"          \"droid\"         \"female\"        \"hermaphrodite\"\n\nfct_count(sw$gender)\n\n# A tibble: 4 × 2\n  f                 n\n  &lt;fct&gt;         &lt;int&gt;\n1 male             62\n2 droid             5\n3 female           19\n4 hermaphrodite     1\n\n\nCeci complique les opérations de recodage car du coup l’opération suivante, qui tente de modifier une modalité de la variable, aboutit à un avertissement, et l’opération n’est pas effectuée.\n\nsw$gender[sw$gender == \"male\"] &lt;- \"homme\"\n\nforcats est une extension facilitant la manipulation des variables qualitatives, qu’elles soient sous forme de vecteurs character ou de facteurs. Elle fait partie du tidyverse, et est donc automatiquement chargée par :\n\nlibrary(tidyverse)\n\n\n\n4.3.2 Modifier les modalités d’une variable qualitative\nUne opération courante consiste à modifier les valeurs d’une variable qualitative, que ce soit pour avoir des intitulés plus courts ou plus clairs ou pour regrouper des modalités entre elles.\nIl existe plusieurs possibilités pour effectuer ce type de recodage, mais ici on va utiliser la fonction fct_recode de l’extension forcats. Celle-ci prend en argument une liste de recodages sous la forme \"Nouvelle valeur\" = \"Ancienne valeur\".\nUn exemple :\n\nf &lt;- c(\"Pomme\", \"Poire\", \"Pomme\", \"Cerise\")\nf &lt;- fct_recode(\n    f,\n    \"Fraise\" = \"Pomme\",\n    \"Ananas\" = \"Poire\"\n)\nf\n\n[1] Fraise Ananas Fraise Cerise\nLevels: Cerise Ananas Fraise\n\n\nSi on veut par exemple traduire nos genres dans notre jeu de données\n\nsw$gender &lt;- fct_recode(\n    sw$gender,\n    \"homme\" = \"male\",\n    \"femme\" = \"female\"\n)\n\nfct_count(sw$gender)\n\n# A tibble: 4 × 2\n  f                 n\n  &lt;fct&gt;         &lt;int&gt;\n1 homme            62\n2 droid             5\n3 femme            19\n4 hermaphrodite     1\n\n\nAttention, les anciennes valeurs saisies doivent être exactement égales aux valeurs des modalités de la variable recodée : toute différence d’accent ou d’espace fera que ce recodage ne sera pas pris en compte. Dans ce cas, forcats affiche un avertissement nous indiquant qu’une valeur saisie n’a pas été trouvée dans les modalités de la variable.\n\nsw$gender &lt;- fct_recode(\n    sw$gender,\n    \"hermaphrodite\" = \"hérmaphrodite\"\n)\n\nWarning: Unknown levels in `f`: hérmaphrodite\n\n\nSi on souhaite recoder une modalité de la variable en NA, il faut (contre intuitivement) lui assigner la valeur NULL.\n\nsw$gender &lt;- fct_recode(\n    sw$gender,\n    NULL = \"droid\"\n)\n\nfct_count(sw$gender)\n\n# A tibble: 4 × 2\n  f                 n\n  &lt;fct&gt;         &lt;int&gt;\n1 homme            62\n2 femme            19\n3 hermaphrodite     1\n4 &lt;NA&gt;              5\n\n\nÀ l’inverse, si on souhaite recoder les NA d’une variable, on utilisera la fonction fct_na_value_to_level, qui convertit toutes les valeurs manquantes (NA) d’un facteur en une modalité spécifique.\n\nsw$gender &lt;- fct_na_value_to_level(sw$gender, level = \"droid\")\n\nfct_count(sw$gender)\n\n# A tibble: 4 × 2\n  f                 n\n  &lt;fct&gt;         &lt;int&gt;\n1 homme            62\n2 femme            19\n3 hermaphrodite     1\n4 droid             5\n\n\nD’autres fonctions sont proposées par forcats pour faciliter certains recodage, comme fct_collapse, qui propose une autre syntaxe pratique quand on doit regrouper ensemble des modalités. Par exemple, si nous avions différentes orthographe pour les mêmes valeurs (ici il nous dira qu’il ne connait pas certains levels ce qui est normale) :\n\nsw$gender &lt;- fct_collapse(\n    sw$gender,\n    \"male\" = c(\"homme\", \"Homme\"),\n    \"female\" = c(\"femme\", \"Femme\")\n)\n\nWarning: Unknown levels in `f`: Homme, Femme\n\nfct_count(sw$gender)\n\n# A tibble: 4 × 2\n  f                 n\n  &lt;fct&gt;         &lt;int&gt;\n1 male             62\n2 female           19\n3 hermaphrodite     1\n4 droid             5\n\n\nN’hésitez pas à consulter la documentation de focats et sa Cheat Sheet !\n\n\n4.3.3 Ordonner les modalités d’une variable qualitative\nL’avantage des facteurs (par rapport aux vecteurs de type character) est que leurs modalités peuvent être ordonnées, ce qui peut faciliter la lecture de tableaux ou graphiques.\nOn peut ordonner les modalités d’un facteur manuellement, par exemple avec la fonction fct_relevel() de l’extension forcats.\n\nsw$gender &lt;- fct_relevel(\n    sw$gender,\n    \"male\", \"female\", \"droid\",\n    \"hermaphrodite\"\n)\n\nfct_count(sw$gender)\n\n# A tibble: 4 × 2\n  f                 n\n  &lt;fct&gt;         &lt;int&gt;\n1 male             62\n2 female           19\n3 droid             5\n4 hermaphrodite     1\n\n\nUne autre possibilité est d’ordonner les modalités d’un facteur selon les valeurs d’une autre variable. Par exemple, si nous voulons étudier la taille en fonction de l’espèce :\n\nsw$species &lt;- as_factor(sw$species)\nsw$species &lt;- fct_na_value_to_level(sw$species, level = \"Unknown\")\n\nlibrary(ggplot2)\nggplot(sw) +\n  geom_boxplot(aes(x = species, y = height)) +\n  scale_x_discrete(guide = guide_axis(angle = 90))\n\n\n\n\n\n\n\n\nLe graphique pourrait être plus lisible si les modalités étaient triées par la taille mediane croissante. On peut dans ce cas utiliser la fonction fct_reorder. Celle-ci prend 3 arguments : le facteur à réordonner, la variable dont les valeurs doivent être utilisées pour ce réordonnancement, et enfin une fonction à appliquer à cette deuxième variable.\n\nsw$spec_heigt &lt;- fct_reorder(sw$species, sw$height, median)\n\nggplot(sw) +\n  geom_boxplot(aes(x = spec_heigt, y = height)) +\n  scale_x_discrete(guide = guide_axis(angle = 90))\n\n\n\n\n\n\n\n\nOn peut aussi effectuer le réordonnancement directement dans l’appel à ggplot2, sans créer de nouvelle variable.\n\nggplot(sw) +\n  geom_boxplot(\n    aes(\n      x = fct_reorder(species, height, median),\n      y = height\n    )\n  ) +\n  scale_x_discrete(guide = guide_axis(angle = 90))\n\nLorsqu’on effectue un diagramme en barres avec geom_bar, on peut aussi réordonner les modalités selon leurs effectifs à l’aide de fct_infreq.\n\nggplot(sw) +\n  geom_bar(aes(x = fct_infreq(species)))+\n  scale_x_discrete(guide = guide_axis(angle = 90))\n\n\n\n\n\n\n\n\n\n\n4.3.4 ifelse\nifelse prend trois arguments : un test, une valeur à renvoyer si le test est vrai, et une valeur à renvoyer si le test est faux.\nVoici un exemple simple :\n\nv &lt;- c(12, 14, 8, 16)\nifelse(v &gt; 10, \"Supérieur à 10\", \"Inférieur à 10\")\n\n[1] \"Supérieur à 10\" \"Supérieur à 10\" \"Inférieur à 10\" \"Supérieur à 10\"\n\n\nLa fonction permet d’utiliser des tests combinant plusieurs variables. Par exemple, imaginons qu’on souhaite créer une nouvelle variable indiquant les hommes de plus de 180cm :\n\nsw$cat &lt;- ifelse(\n    sw$gender == \"male\" & sw$height &gt; 180,\n    \"Homme grand\",\n    \"Autre\"\n)\n\nview(sw)\n\n\n\n4.3.5 case_when\ncase_when est une généralisation du ifelse qui permet d’indiquer plusieurs tests et leurs valeurs associées.\nImaginons qu’on souhaite créer une nouvelle variable permettant d’identifier les hommes de plus de 60 ans, les femmes de plus de 60 ans, et les autres. On peut utiliser la syntaxe suivante :\n\nsw$cat &lt;- case_when(\n    sw$height &gt; 180 & sw$gender == \"male\" ~ \"Homme grand\",\n    sw$height &gt; 180 & sw$gender == \"female\" ~ \"Femme grande\",\n    TRUE ~ \"Autre\"\n)\n\nView(sw)\n\ncase_when prend en arguments une série d’instructions sous la forme condition ~ valeur. Il les exécute une par une, et dès qu’une condition est vraie, il renvoie la valeur associée.\nLa dernière clause TRUE ~ \"Autre\" permet d’assigner une valeur à toutes les lignes pour lesquelles aucune des conditions précédentes n’est vraie.\n\n\n\n\n\n\nWarning\n\n\n\nAttention : comme les conditions sont testées l’une après l’autre et que la valeur renvoyée est celle correspondant à la première condition vraie, l’ordre de ces conditions est très important. Il faut absolument aller du plus spécifique au plus général."
  },
  {
    "objectID": "SFC1018_Traitement_R.html#découper-une-variable-numérique-en-classes",
    "href": "SFC1018_Traitement_R.html#découper-une-variable-numérique-en-classes",
    "title": "Traitement de données avec R",
    "section": "4.4 Découper une variable numérique en classes",
    "text": "4.4 Découper une variable numérique en classes\nUne autre opération courante consiste à découper une variable numérique en classes. Par exemple, on voudra transformer une variable height en une variable qualitative avec des catégories Moins de 150cm, 150-180 cm, etc.\nOn utilise pour cela la fonction cut() :\n\nsw$heightcl &lt;- cut(sw$height, breaks = 5)\n\nfct_count(sw$heightcl)\n\n# A tibble: 6 × 2\n  f              n\n  &lt;fct&gt;      &lt;int&gt;\n1 (65.8,106]     7\n2 (106,145]      3\n3 (145,185]     42\n4 (185,224]     25\n5 (224,264]      4\n6 &lt;NA&gt;           6\n\n\nSi on donne un nombre entier à l’argument breaks, un nombre correspondant de classes d’amplitudes égales sont automatiquement calculées. Comme il est souvent préférable d’avoir des limites “arrondies”, on peut aussi spécifier ces dernières manuellement en passant un vecteur à breaks.\n\nsw$heightcl &lt;- cut(\n    sw$height,\n    breaks = c(50, 150, 175, 185, 200, 225, 300)\n)\n\nfct_count(sw$heightcl)\n\n# A tibble: 7 × 2\n  f             n\n  &lt;fct&gt;     &lt;int&gt;\n1 (50,150]     12\n2 (150,175]    21\n3 (175,185]    20\n4 (185,200]    18\n5 (200,225]     6\n6 (225,300]     4\n7 &lt;NA&gt;          6"
  },
  {
    "objectID": "SFC1018_Traitement_R.html#sec-concat",
    "href": "SFC1018_Traitement_R.html#sec-concat",
    "title": "Traitement de données avec R",
    "section": "5.1 Concaténer des chaînes",
    "text": "5.1 Concaténer des chaînes\nLa première opération de base consiste à concaténer des chaînes de caractères entre elles. On peut le faire avec la fonction paste.\nPar exemple, si on veut concaténer l’adresse et la ville :\n\npaste(d$adresse, d$ville)\n\n[1] \"3 rue des Fleurs Laval\"              \n[2] \"47 ave de la Libération Montréal\"    \n[3] \"12 rue du 17 octobre 1961 Québec\"    \n[4] \"221 avenue de la Libération Montréal\"\n\n\nPar défaut, paste concatène en ajoutant un espace entre les différentes chaînes. On peut spécifier un autre séparateur avec son argument sep :\n\npaste(d$adresse, d$ville, sep = \" - \")\n\n[1] \"3 rue des Fleurs - Laval\"              \n[2] \"47 ave de la Libération - Montréal\"    \n[3] \"12 rue du 17 octobre 1961 - Québec\"    \n[4] \"221 avenue de la Libération - Montréal\"\n\n\nIl existe une variante, paste0, qui concatène sans mettre de séparateur, et qui est légèrement plus rapide :\n\npaste0(d$adresse, d$ville)\n\n[1] \"3 rue des FleursLaval\"               \"47 ave de la LibérationMontréal\"    \n[3] \"12 rue du 17 octobre 1961Québec\"     \"221 avenue de la LibérationMontréal\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nÀ noter que paste et paste0 sont des fonctions R de base. L’équivalent pour stringr se nomme str_c.\n\n\nParfois on cherche à concaténer les différents éléments d’un vecteur non pas avec ceux d’un autre vecteur, comme on l’a fait précédemment, mais entre eux. Dans ce cas paste seule ne fera rien :\n\npaste(d$ville)\n\n[1] \"Laval\"    \"Montréal\" \"Québec\"   \"Montréal\"\n\n\nIl faut lui ajouter un argument collapse, avec comme valeur la chaîne à utiliser pour concaténer les éléments :\n\npaste(d$ville, collapse = \", \")\n\n[1] \"Laval, Montréal, Québec, Montréal\""
  },
  {
    "objectID": "SFC1018_Traitement_R.html#convertir-en-majuscules-minuscules",
    "href": "SFC1018_Traitement_R.html#convertir-en-majuscules-minuscules",
    "title": "Traitement de données avec R",
    "section": "5.2 Convertir en majuscules / minuscules",
    "text": "5.2 Convertir en majuscules / minuscules\nLes fonctions str_to_lower, str_to_upper et str_to_title permettent respectivement de mettre en minuscules, mettre en majuscules, ou de capitaliser les éléments d’un vecteur de chaînes de caractères :\n\nstr_to_lower(d$nom)\n\n[1] \"mr félicien machin\"  \"mme raymonde bidule\" \"m. martial truc\"    \n[4] \"mme huguette chose\" \n\n\n\nstr_to_upper(d$nom)\n\n[1] \"MR FÉLICIEN MACHIN\"  \"MME RAYMONDE BIDULE\" \"M. MARTIAL TRUC\"    \n[4] \"MME HUGUETTE CHOSE\" \n\n\n\nstr_to_title(d$nom)\n\n[1] \"Mr Félicien Machin\"  \"Mme Raymonde Bidule\" \"M. Martial Truc\"    \n[4] \"Mme Huguette Chose\""
  },
  {
    "objectID": "SFC1018_Traitement_R.html#découper-des-chaînes",
    "href": "SFC1018_Traitement_R.html#découper-des-chaînes",
    "title": "Traitement de données avec R",
    "section": "5.3 Découper des chaînes",
    "text": "5.3 Découper des chaînes\nLa fonction str_split permet de “découper” une chaîne de caractère en fonction d’un délimiteur. On passe la chaîne en premier argument, et le délimiteur en second :\n\nstr_split(\"un-deux-trois\", \"-\")\n\n[[1]]\n[1] \"un\"    \"deux\"  \"trois\"\n\n\nOn peut appliquer la fonction à un vecteur, dans ce cas le résultat sera une liste :\n\nstr_split(d$nom, \" \")\n\n[[1]]\n[1] \"Mr\"       \"Félicien\" \"Machin\"  \n\n[[2]]\n[1] \"Mme\"      \"Raymonde\" \"Bidule\"  \n\n[[3]]\n[1] \"M.\"      \"Martial\" \"Truc\"   \n\n[[4]]\n[1] \"Mme\"      \"Huguette\" \"Chose\"   \n\n\nOu un tableau (plus précisément une matrice) si on ajoute simplify = TRUE.\n\nstr_split(d$nom, \" \", simplify = TRUE)\n\n     [,1]  [,2]       [,3]    \n[1,] \"Mr\"  \"Félicien\" \"Machin\"\n[2,] \"Mme\" \"Raymonde\" \"Bidule\"\n[3,] \"M.\"  \"Martial\"  \"Truc\"  \n[4,] \"Mme\" \"Huguette\" \"Chose\" \n\n\nSi on souhaite créer de nouvelles colonnes dans un tableau de données en découpant une colonne de type texte, on pourra utiliser la fonction separate de l’extension tidyr. Celle-ci est expliquée ?@sec-separate.\nVoici juste un exemple de son utilisation :\n\nlibrary(tidyr)\nd %&gt;% separate(nom, c(\"genre\", \"prenom\", \"nom\"), sep = \" \")\n\n# A tibble: 4 × 5\n  genre prenom   nom    adresse                     ville   \n  &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;                       &lt;chr&gt;   \n1 Mr    Félicien Machin 3 rue des Fleurs            Laval   \n2 Mme   Raymonde Bidule 47 ave de la Libération     Montréal\n3 M.    Martial  Truc   12 rue du 17 octobre 1961   Québec  \n4 Mme   Huguette Chose  221 avenue de la Libération Montréal"
  },
  {
    "objectID": "SFC1018_Traitement_R.html#extraire-des-sous-chaînes-par-position",
    "href": "SFC1018_Traitement_R.html#extraire-des-sous-chaînes-par-position",
    "title": "Traitement de données avec R",
    "section": "5.4 Extraire des sous-chaînes par position",
    "text": "5.4 Extraire des sous-chaînes par position\nLa fonction str_sub permet d’extraire des sous-chaînes par position, en indiquant simplement les positions des premier et dernier caractères :\n\nstr_sub(d$ville, 1, 3)\n\n[1] \"Lav\" \"Mon\" \"Qué\" \"Mon\""
  },
  {
    "objectID": "SFC1018_Traitement_R.html#sec-str-detect",
    "href": "SFC1018_Traitement_R.html#sec-str-detect",
    "title": "Traitement de données avec R",
    "section": "5.5 Détecter des motifs",
    "text": "5.5 Détecter des motifs\nstr_detect permet de détecter la présence d’un motif parmi les élements d’un vecteur. Par exemple, si on souhaite identifier toutes les adresses contenant “Libération” :\n\nstr_detect(d$adresse, \"Libération\")\n\n[1] FALSE  TRUE FALSE  TRUE\n\n\nstr_detect renvoie un vecteur de valeurs logiques et peut donc être utilisée, par exemple, avec le verbe filter de dplyr pour extraire des sous-populations.\nUne variante, str_count, compte le nombre d’occurrences d’une chaîne pour chaque élément d’un vecteur :\n\nstr_count(d$ville, \"s\")\n\n[1] 0 0 0 0\n\n\nOn peut aussi utiliser str_subset pour ne garder d’un vecteur que les éléments correspondant au motif :\n\nstr_subset(d$adresse, \"Libération\")\n\n[1] \"47 ave de la Libération\"     \"221 avenue de la Libération\""
  },
  {
    "objectID": "SFC1018_Traitement_R.html#extraire-des-motifs",
    "href": "SFC1018_Traitement_R.html#extraire-des-motifs",
    "title": "Traitement de données avec R",
    "section": "5.6 Extraire des motifs",
    "text": "5.6 Extraire des motifs\nstr_extract permet d’extraire les valeurs correspondant à un motif. Si on lui passe comme motif une chaîne de caractère, cela aura peu d’intérêt :\n\nstr_extract(d$adresse, \"Libération\")\n\n[1] NA           \"Libération\" NA           \"Libération\"\n\n\nstr_extract ne récupère que la première occurrence du motif. Si on veut toutes les extraire on peut utiliser str_extract_all."
  },
  {
    "objectID": "SFC1018_Traitement_R.html#remplacer-des-motifs",
    "href": "SFC1018_Traitement_R.html#remplacer-des-motifs",
    "title": "Traitement de données avec R",
    "section": "5.7 Remplacer des motifs",
    "text": "5.7 Remplacer des motifs\nLa fonction str_replace_all permet de remplacer une chaîne ou un motif par une autre.\nPar exemple, on peut remplacer les occurrence de “Mr” par “M.” dans notre variable nom :\n\nstr_replace_all(d$nom, \"Mr\", \"M.\")\n\n[1] \"M. Félicien Machin\"  \"Mme Raymonde Bidule\" \"M. Martial Truc\"    \n[4] \"Mme Huguette Chose\" \n\n\nOn peut également spécifier plusieurs remplacements en une seule fois :\n\nstr_replace_all(\n    d$adresse,\n    c(\"avenue\" = \"Avenue\", \"ave\" = \"Avenue\", \"rue\" = \"Rue\")\n)\n\n[1] \"3 Rue des Fleurs\"            \"47 Avenue de la Libération\" \n[3] \"12 Rue du 17 octobre 1961\"   \"221 Avenue de la Libération\""
  },
  {
    "objectID": "SFC1018_Traitement_R.html#ressources",
    "href": "SFC1018_Traitement_R.html#ressources",
    "title": "Traitement de données avec R",
    "section": "5.8 Ressources",
    "text": "5.8 Ressources\nL’ouvrage R for Data Science, accessible en ligne, contient un chapitre entier sur les chaînes de caractères et les expressions régulières (en anglais).\nLe site officiel de stringr contient une liste des fonctions et les pages d’aide associées, ainsi qu’un article dédié aux expressions régulières.\nPour des besoins plus pointus, on pourra aussi utiliser l’extension stringi sur laquelle est elle-même basée stringr."
  },
  {
    "objectID": "SFC1018_Traitement_R.html#exercice-2",
    "href": "SFC1018_Traitement_R.html#exercice-2",
    "title": "Traitement de données avec R",
    "section": "6.1 Exercice 2",
    "text": "6.1 Exercice 2\nToujours avec notre jeu de données sur les personnages de Star Wars, nous allons finir de préparer et de nettoyer nos données.\nNormalement les colonnes height, mass, gender et species ont déjà été traitées.\nPour toutes les autres colonnes: - Assurez vous que toutes la valeurs \"none\" soient transformées en NA. - Transformez la colonne homeworld en facteurs et attribuez la valeur de Unknown pour ceux dont on ne connait le monde d’origine. - Pour la colonne birth_year, supprimez le BBY pour ne garder que le nombre et transformez cette colonne en nombre."
  },
  {
    "objectID": "SFC1018_Traitement_R.html#footnotes",
    "href": "SFC1018_Traitement_R.html#footnotes",
    "title": "Traitement de données avec R",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nQuand on veut utiliser des noms de ce type, on doit les entourer avec des backticks (`)↩︎\nDans R de base, si une table d contient une colonne qualif, d$qual retournera cette colonne.↩︎\nLe fait que le séparateur des décimales soit un point ou une virgule peut varier d’un système à l’autre (Mac vs Windows vs langue du système).↩︎\nPour accéder à la page de documentation de fonctions comme %in%, on ne peut pas utiliser ?%in%, qui renvoie une erreur. Vous pouvez faire ?\"%in%\", help(\"%in%\") ou, dans ce cas, ?match, car les deux fonctions sont documentées sur la même page d’aide.↩︎"
  },
  {
    "objectID": "SFC1018_Intro_R.html",
    "href": "SFC1018_Intro_R.html",
    "title": "Introduction à R",
    "section": "",
    "text": "Ce document est une introduction à R pour l’analyse de données. Il a été construit en adaptant différents contenus, notamment :\n\nIntroduction à R et au tidyverse (Julien Barnier - 2023)\nR for Data Science (2e) (Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund - 2023)\n\nVous pourrez trouver de nombreuses ressources utiles sur Internet. Nous vous conseillons les très pratique CheatSheet :\n\nUne cheatsheet pour R\nD’autres cheatsheets"
  },
  {
    "objectID": "SFC1018_Intro_R.html#les-variables",
    "href": "SFC1018_Intro_R.html#les-variables",
    "title": "Introduction à R",
    "section": "2.1 Les variables",
    "text": "2.1 Les variables\nFaire des calculs c’est bien, mais il serait intéressant de pouvoir stocker un résultat quelque part pour pouvoir le réutiliser ultérieurement sans avoir à faire du copier/coller.\nPour conserver le résultat d’une opération, on peut le stocker dans une variable à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans une variable dont le nom est indiqué à sa gauche.\nPar exemple :\n\nx &lt;- 2\n\nCette commande peut se lire “prend la valeur 2 et mets la dans une variable qui s’appelle x”.\nSi on exécute une commande comportant juste le nom d’une variable, R affiche son contenu.\n\nx\n\n[1] 2\n\n\nOn voit donc que notre variable x contient bien la valeur 2.\nOn peut évidemment réutiliser cette variable dans d’autres opérations : R le remplacera alors par sa valeur.\n\nx + 4\n\n[1] 6\n\n\nOn peut créer autant de variables que l’on veut.\n\nx &lt;- 2\ny &lt;- 5\nresultat &lt;- x + y\nresultat\n\n[1] 7\n\n\nQuand on assigne une nouvelle valeur à une variable déjà existante, la valeur précédente est perdue. Les variables n’ont pas de mémoire.\n\nx &lt;- 2\nx &lt;- 5\nx\n\n[1] 5\n\n\nDe la même manière, assigner une variable à une autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de la variable de droite dans celle de gauche :\n\nx &lt;- 1\ny &lt;- 3\nx &lt;- y\nx\n\n[1] 3\n\n## Si on modifie y, cela ne modifie pas x\ny &lt;- 4\nx\n\n[1] 3\n\n\nOn le verra, les variable peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou \") :\n\nchien &lt;- \"Chihuahua\"\nchien\n\n[1] \"Chihuahua\""
  },
  {
    "objectID": "SFC1018_Intro_R.html#les-vecteurs",
    "href": "SFC1018_Intro_R.html#les-vecteurs",
    "title": "Introduction à R",
    "section": "2.2 Les vecteurs",
    "text": "2.2 Les vecteurs\nSi nous voulons stocker plusieurs valeurs d’un coup, nous pouvons le faire dans un seul objet, de type vecteur, avec la syntaxe suivante :\n\ntailles &lt;- c(156, 164, 197, 147, 173)\n\nSi on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies.\n\ntailles\n\n[1] 156 164 197 147 173\n\n\nUn vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre.\nL’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire :\n\ntailles_m &lt;- tailles / 100\ntailles_m\n\n[1] 1.56 1.64 1.97 1.47 1.73\n\n\nCela fonctionne pour toutes les opérations de base.\n\ntailles + 10\n\n[1] 166 174 207 157 183\n\ntailles^2\n\n[1] 24336 26896 38809 21609 29929\n\n\nImaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut créer un deuxième vecteur :\n\npoids &lt;- c(45, 59, 110, 44, 88)\n\nOn peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré :\n\nimc &lt;- poids / (tailles / 100) ^ 2\nimc\n\n[1] 18.49112 21.93635 28.34394 20.36189 29.40292\n\n\nUn vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères. Une chaîne de caractère contient du texte libre, délimité par des guillemets simples ou doubles.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\ndiplome\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"CAP\"   \"Bac+3\"\n\n\nL’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R :\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nEnfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré.\n\ndiplome[2]\n\n[1] \"Bac\"\n\n\nCette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur.\nDernière remarque, si on affiche dans la console un vecteur avec beaucoup d’éléments, ceux-ci seront répartis sur plusieurs lignes. Par exemple, si on a un vecteur de 50 nombres on peut obtenir quelque chose comme :\n [1] 294 425 339 914 114 896 716 648 915 587 181 926 489\n[14] 848 583 182 662 888 417 133 146 322 400 698 506 944\n[27] 237 324 333 443 487 658 793 288 897 588 697 439 697\n[40] 914 694 126 969 744 927 337 439 226 704 635\nOn remarque que R ajoute systématiquement un nombre entre crochets au début de chaque ligne : il s’agit en fait de la position du premier élément de la ligne dans le vecteur. Ainsi, le 848 de la deuxième ligne est le 14e élément du vecteur, le 914 de la dernière ligne est le 40e, etc.\nCeci explique le [1] qu’on obtient quand on affiche un simple nombre1 :\n [1] 4"
  },
  {
    "objectID": "SFC1018_Intro_R.html#fonctions",
    "href": "SFC1018_Intro_R.html#fonctions",
    "title": "Introduction à R",
    "section": "2.3 Fonctions",
    "text": "2.3 Fonctions\n\n2.3.1 Principe\nNous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard.\nPour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions.\nFormellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat.\nPrenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière :\n\nlength(tailles)\n\n[1] 5\n\n\nIci, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre.\nAutre exemple, les fonctions min et max retournent respectivement les valeurs minimales et maximales d’un vecteur de nombres.\n\nmin(tailles)\n\n[1] 147\n\nmax(tailles)\n\n[1] 197\n\n\nLa fonction mean calcule et retourne la moyenne d’un vecteur de nombres.\n\nmean(tailles)\n\n[1] 167.4\n\n\nLa fonction sum retourne la somme de tous les éléments du vecteur.\n\nsum(tailles)\n\n[1] 837\n\n\nJusqu’à présent on n’a vu que des fonctions qui calculent et retournent un unique nombre. Mais une fonction peut renvoyer d’autres types de résultats. Par exemple, la fonction range (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum.\n\nrange(tailles)\n\n[1] 147 197\n\n\nOu encore, la fonction unique, qui supprime toutes les valeurs en double dans un vecteur, qu’il s’agisse de nombres ou de chaînes de caractères.\n\ndiplome &lt;- c(\"CAP\", \"Bac\", \"Bac+2\", \"CAP\", \"Bac+3\")\nunique(diplome)\n\n[1] \"CAP\"   \"Bac\"   \"Bac+2\" \"Bac+3\"\n\n\n\n\n2.3.2 Arguments\nUne fonction peut prendre plusieurs arguments, dans ce cas on les indique entre parenthèses en les séparant par des virgules.\nOn a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction c, qui combine l’ensemble de ses arguments en un vecteur2.\n\ntailles &lt;- c(156, 164, 197, 181, 173)\n\nIci, c est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs.\nSupposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre, ou notre mètre mesureur était en panne). On symbolise celle-ci dans R avec le code interne NA.\n\ntailles &lt;- c(156, 164, 197, NA, 173)\ntailles\n\n[1] 156 164 197  NA 173\n\n\n\n\n\n\n\n\nNote\n\n\n\nNA est l’abbréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc.\n\n\nSi on calcule maintenant la taille moyenne à l’aide de la fonction mean, on obtient :\n\nmean(tailles)\n\n[1] NA\n\n\nEn effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Dans ce cas il considère que la moyenne est elle-même “non disponible” et renvoie donc NA comme résultat.\nOn peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abbréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai).\n\nmean(tailles, na.rm = TRUE)\n\n[1] 172.5\n\n\nPositionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul.\nSi on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes :\n\nmean(tailles)\n\n[1] NA\n\nmean(tailles, na.rm = FALSE)\n\n[1] NA\n\n\n\n\n\n\n\n\nNote\n\n\n\nLorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé.\n\n\n\n\n2.3.3 Aide sur une fonction\nIl est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help.\n\nhelp(\"mean\")\n\nOn peut aussi utiliser le raccourci ?mean.\nCes deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée.\nDans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide."
  },
  {
    "objectID": "SFC1018_Intro_R.html#commentaires",
    "href": "SFC1018_Intro_R.html#commentaires",
    "title": "Introduction à R",
    "section": "2.4 Commentaires",
    "text": "2.4 Commentaires\nLes commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption.\nPour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jussqu’à la fin de la ligne.\nOn peut donc documenter le script précédent :\n\n# Saisie des tailles et poids des enquêtés\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\n# Calcul des tailles et poids moyens\nmean(tailles)\nmean(poids)\n\n# Calcul de l'IMC (poids en kilo divisé par les tailles en mètre au carré)\nimc &lt;- poids / (tailles / 100) ^ 2\n# Valeurs extrêmes de l'IMC\nmin(imc)\nmax(imc)"
  },
  {
    "objectID": "SFC1018_Intro_R.html#sec-install",
    "href": "SFC1018_Intro_R.html#sec-install",
    "title": "Introduction à R",
    "section": "2.5 Installation de Packages",
    "text": "2.5 Installation de Packages\nR étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs et utilisatrices de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network).\nPour installer une extension, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Il suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install.\nOn peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package tidyverse on peut exécuter la commande :\n\ninstall.packages(\"tidyverse\")\n\nInstaller une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC.\nUne fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de tidyverse, vous devrez exécuter la commande suivante :\n\nlibrary(tidyverse)\n\nAinsi, on regroupe en général en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script."
  },
  {
    "objectID": "SFC1018_Intro_R.html#exercices",
    "href": "SFC1018_Intro_R.html#exercices",
    "title": "Introduction à R",
    "section": "2.6 Exercices",
    "text": "2.6 Exercices\n\n2.6.1 Exercice 1\nConstruire le vecteur x suivant :\n\n\n[1] 120 134 256  12\n\n\nUtiliser ce vecteur x pour générer les deux vecteurs suivants :\n\n\n[1] 220 234 356 112\n\n\n[1] 240 268 512  24\n\n\n\n\n2.6.2 Exercice 2\nOn a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage :\n\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\nconjoint2 &lt;- c(1450, 1870, 1690, 0)\nnb_personnes &lt;- c(4, 2, 3, 2)\n\nCalculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage.\nCalculer le revenu minimum et maximum parmi ceux du premier conjoint.\n\n\n2.6.3 Exercice 3\nRecommencer avec les revenus suivants, parmi lesquels l’un des enquetés n’a pas voulu répondre :\n\nconjoint1 &lt;- c(1200, 1180, 1750, NA)\n\n\n\n2.6.4 Exercice 4\nLes deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes pour chaque mois de l’année pour la ville de Lyon (moyennes calculées sur la période 1981-2010) :\n\ntemperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4)\nprecipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2)\n\nCalculer la température moyenne sur l’année.\nCalculer la quantité totale de précipitations sur l’année.\nÀ quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire.\n\ncumsum(precipitations)\n\n [1]  47.2  91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 831.9\n\n\nMême question pour :\n\ndiff(temperature)\n\n [1]  1.4  3.6  3.0  4.4  3.6  2.8 -0.6 -4.0 -4.2 -5.8 -3.2\n\n\n\n\n2.6.5 Exercice 5\nOn a relevé les notes en maths, anglais et sport d’une classe de 6 élèves et on a stocké ces données dans trois vecteurs :\n\nmaths &lt;- c(12, 16, 8, 18, 6, 10)\nanglais &lt;- c(14, 9, 13, 15, 17, 11)\nsport &lt;- c(18, 11, 14, 10, 8, 12)\n\nCalculer la moyenne des élèves de la classe en anglais.\nCalculer la moyenne générale de chaque élève (la moyenne des ses notes dans les trois matières).\nEssayez de comprendre le résultat des deux fonctions suivantes (vous pouvez vous aider de la page d’aide de ces fonctions) :\n\npmin(maths, anglais, sport)\n\n[1] 12  9  8 10  6 10\n\n\n\npmax(maths, anglais, sport)\n\n[1] 18 16 14 18 17 12"
  },
  {
    "objectID": "SFC1018_Intro_R.html#tableau-de-données-data-frame",
    "href": "SFC1018_Intro_R.html#tableau-de-données-data-frame",
    "title": "Introduction à R",
    "section": "3.1 Tableau de données (data frame)",
    "text": "3.1 Tableau de données (data frame)\nUn data frame (ou tableau de données, ou table) est un type d’objet R qui contient des données au format tabulaire, avec les observations en ligne et les variables en colonnes, comme dans une feuille de tableur Excel.\nSi on se contente d’exécuter le nom de notre tableau de données R va, comme à son habitude, nous l’afficher dans la console, ce qui est tout sauf utile.\n\ndiamonds\n\nUne autre manière d’afficher le contenu du tableau est de cliquer sur l’icône en forme de tableau à droite du nom de l’objet dans l’onglet Environment ou d’utiliser la fonction View :\n\nView(diamonds)\n\nDans les deux cas votre tableau devrait s’afficher dans RStudio sous forme de tableau directement.\nIl est important de comprendre que l’objet diamonds contient l’intégralité des données du tableau. On voit donc qu’un objet peut contenir des données de types très différents (simple nombre, texte, vecteur, tableau de données entier), et être potentiellement de très grande taille3.\n\n\n\n\n\n\nNote\n\n\n\nSous R, on peut importer ou créer autant de tableaux de données qu’on le souhaite, dans les limites des capacités de sa machine.\n\n\nUn data frame peut être manipulé comme les autres objets vus précédemment. On peut par exemple faire :\n\nd &lt;- diamonds\n\nce qui va entraîner la copie de l’ensemble de nos données dans un nouvel objet nommé d. Ceci peut paraître parfaitement inutile mais a en fait l’avantage de fournir un objet avec un nom beaucoup plus court, ce qui diminuera la quantité de texte à saisir par la suite.\nPour résumer, notre fichier de travail sur les données des diamants pourraient donc ressembler à ceci :\n\n## Chargement des extensions nécessaires\nlibrary(ggplot2)\n\n## Jeu de données diamonds\ndata(diamonds)\nd &lt;- diamonds\n\n\n3.1.1 Structure du tableau\nUn tableau étant un objet comme un autre, on peut lui appliquer des fonctions. Par exemple, nrow et ncol retournent le nombre de lignes et de colonnes du tableau.\n\nnrow(d)\n\n[1] 53940\n\n\n\nncol(d)\n\n[1] 10\n\n\nLa fonction dim renvoie ses dimensions, donc les deux nombres précédents.\n\ndim(d)\n\n[1] 53940    10\n\n\nLa fonction names retourne les noms des colonnes du tableau, c’est-à-dire la liste de nos variables.\n\nnames(d)\n\n [1] \"carat\"   \"cut\"     \"color\"   \"clarity\" \"depth\"   \"table\"   \"price\"  \n [8] \"x\"       \"y\"       \"z\"      \n\n\nEnfin, la fonction str renvoie un descriptif plus détaillé de la structure du tableau. Elle liste les différentes variables, indique leur type 4 et affiche les premières valeurs.\n\nstr(d)\n\ntibble [53,940 × 10] (S3: tbl_df/tbl/data.frame)\n $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n $ cut    : Ord.factor w/ 5 levels \"Fair\"&lt;\"Good\"&lt;..: 5 4 2 4 2 3 3 3 1 3 ...\n $ color  : Ord.factor w/ 7 levels \"D\"&lt;\"E\"&lt;\"F\"&lt;\"G\"&lt;..: 2 2 2 6 7 7 6 5 2 5 ...\n $ clarity: Ord.factor w/ 8 levels \"I1\"&lt;\"SI2\"&lt;\"SI1\"&lt;..: 2 3 5 4 2 6 7 3 4 5 ...\n $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...\n\n\nÀ noter que sous RStudio, on peut afficher à tout moment la structure d’un objet en cliquant sur l’icône de triangle sur fond bleu à gauche du nom de l’objet dans l’onglet Environment.\n\n\n3.1.2 Accéder aux variables d’un tableau\nUne opération très importante est l’accès aux variables du tableau (à ses colonnes) pour pouvoir les manipuler, effectuer des calculs, etc. On utilise pour cela l’opérateur $, qui permet d’accéder aux colonnes du tableau. Ainsi, si l’on tape :\n\nd$cut\n\n  [1] Ideal     Premium   Good      Premium   Good      Very Good Very Good\n  [8] Very Good Fair      Very Good Good      Ideal     Premium   Ideal    \n [15] Premium   Premium   Ideal     Good      Good      Very Good Good     \n [22] Very Good Very Good Very Good Very Good Very Good Premium   Very Good\n [29] Very Good Very Good Very Good Very Good Very Good Very Good Very Good\n [36] Good      Good      Good      Very Good Ideal     Ideal     Ideal    \n [43] Good      Good      Good      Premium   Very Good Good      Very Good\n [50] Very Good Very Good Ideal     Ideal     Premium   Premium   Ideal    \n [57] Premium   Very Good Very Good Good      Ideal     Premium   Ideal    \n [64] Ideal     Premium   Ideal     Ideal     Very Good Premium   Premium  \n [71] Very Good Very Good Premium   Premium   Good      Very Good Very Good\n [78] Very Good Very Good Very Good Very Good Very Good Ideal     Ideal    \n [85] Good      Premium   Premium   Premium   Premium   Premium   Ideal    \n [92] Fair      Ideal     Very Good Very Good Good      Good      Fair     \n [99] Very Good Premium   Very Good Premium   Ideal     Premium   Ideal    \n[106] Ideal     Premium   Ideal     Ideal     Ideal     Ideal     Ideal    \n[113] Premium   Very Good Ideal     Ideal     Premium   Ideal     Ideal    \n[120] Ideal     Ideal     Ideal     Very Good Fair      Fair      Premium  \n[127] Premium   Very Good Fair      Fair      Ideal     Very Good Ideal    \n[134] Very Good Very Good Premium   Very Good Premium   Ideal     Ideal    \n[141] Premium   Premium   Very Good Very Good Ideal     Good      Very Good\n[148] Very Good Very Good Ideal     Premium   Ideal     Premium   Premium  \n[155] Very Good Ideal     Ideal     Premium   Premium   Ideal     Premium  \n[162] Very Good Very Good Ideal     Ideal     Very Good Very Good Ideal    \n[169] Ideal     Good      Ideal     Premium   Very Good Ideal     Ideal    \n[176] Good      Very Good Very Good Premium   Ideal     Ideal     Ideal    \n[183] Ideal     Ideal     Good      Ideal     Very Good Premium   Very Good\n[190] Good      Good      Ideal     Premium   Premium   Premium   Premium  \n[197] Premium   Premium   Ideal     Premium  \n [ reached getOption(\"max.print\") -- omitted 53740 entries ]\nLevels: Fair &lt; Good &lt; Very Good &lt; Premium &lt; Ideal\n\n\nR va afficher l’ensemble des valeurs de la variable cut dans la console, ce qui est à nouveau fort peu utile. Mais cela nous permet de constater que d$cut est un vecteur de chaînes de caractères tels qu’on en a déjà rencontré précédemment.\nLa fonction table$colonne renvoie donc la colonne nommée colonne du tableau table, c’est-à-dire un vecteur, en général de nombres ou de chaînes de caractères.\nSi on souhaite afficher seulement les premières ou dernières valeurs d’une variable ou d’un tableau, on peut utiliser les fonctions head et tail.\n\nhead(d)\n\n# A tibble: 6 × 10\n  carat cut       color clarity depth table price     x     y     z\n  &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n\n\n\ntail(d, 10)\n\n# A tibble: 10 × 10\n   carat cut       color clarity depth table price     x     y     z\n   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  0.71 Premium   E     SI1      60.5    55  2756  5.79  5.74  3.49\n 2  0.71 Premium   F     SI1      59.8    62  2756  5.74  5.73  3.43\n 3  0.7  Very Good E     VS2      60.5    59  2757  5.71  5.76  3.47\n 4  0.7  Very Good E     VS2      61.2    59  2757  5.69  5.72  3.49\n 5  0.72 Premium   D     SI1      62.7    59  2757  5.69  5.73  3.58\n 6  0.72 Ideal     D     SI1      60.8    57  2757  5.75  5.76  3.5 \n 7  0.72 Good      D     SI1      63.1    55  2757  5.69  5.75  3.61\n 8  0.7  Very Good D     SI1      62.8    60  2757  5.66  5.68  3.56\n 9  0.86 Premium   H     SI2      61      58  2757  6.15  6.12  3.74\n10  0.75 Ideal     D     SI2      62.2    55  2757  5.83  5.87  3.64\n\n\nLe deuxième argument numérique permet d’indiquer le nombre de valeurs à afficher.\n\n\n3.1.3 Créer une nouvelle variable\nOn peut aussi utiliser l’opérateur $ pour créer une nouvelle variable dans notre tableau : pour cela, il suffit de lui assigner une valeur.\nPar exemple, la variable carat contient la masse du diamand. Le carat métrique équivaut à 200mg.\n\nhead(d$carat, 10)\n\n [1] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23\n\n\nOn peut vouloir créer une nouvelle variable dans notre tableau qui contienne la masse du diamant en mg :\n\nd$mass &lt;- d$carat * 200\n\nOn peut alors constater, soit visuellement soit dans la console, qu’une nouvelle variable (une nouvelle colonne) a bien été ajoutée au tableau.\n\nhead(d)\n\n# A tibble: 6 × 11\n  carat cut       color clarity depth table price     x     y     z  mass\n  &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43    46\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31    42\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31    46\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63    58\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75    62\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48    48"
  },
  {
    "objectID": "SFC1018_Intro_R.html#analyse-univariée",
    "href": "SFC1018_Intro_R.html#analyse-univariée",
    "title": "Introduction à R",
    "section": "3.2 Analyse univariée",
    "text": "3.2 Analyse univariée\nOn a donc désormais accès à un tableau de données d, dont les lignes sont des observations (des diamants), et les colonnes des variables (des caractéristiques de chacun de ces diamants), et on sait accéder à ces variables grâce à l’opérateur $.\nSi on souhaite analyser ces variables, les méthodes et fonctions utilisées seront différentes selon qu’il s’agit d’une variable quantitative (variable numérique pouvant prendre un grand nombre de valeurs : l’âge, le revenu, un pourcentage…) ou d’une variable qualitative (variable pouvant prendre un nombre limité de valeurs appelées modalités : la découpe, la couleur ou la clareté).\n\n3.2.1 Analyser une variable quantitative\nUne variable quantitative est une variable de type numérique (un nombre) qui peut prendre un grand nombre de valeurs. On en a plusieurs dans notre jeu de données, notamment la masse (variable carat ou masss) ou les tailles (x, y, etc.).\n\n3.2.1.1 Indicateurs de centralité\nCaractériser une variable quantitative, c’est essayer de décrire la manière dont ses valeurs se répartissent, ou se distribuent.\nPour cela on peut commencer par regarder les valeurs extrêmes, avec les fonctions min, max ou range.\n\nmin(d$carat)\n\n[1] 0.2\n\nmax(d$carat)\n\n[1] 5.01\n\nrange(d$carat)\n\n[1] 0.20 5.01\n\n\nOn peut aussi calculer des indicateurs de centralité : ceux-ci indiquent autour de quel nombre se répartissent les valeurs de la variable. Il y en a plusieurs, le plus connu étant la moyenne, qu’on peut calculer avec la fonction mean.\n\nmean(d$carat)\n\n[1] 0.7979397\n\n\nIl existe aussi la médiane, qui est la valeur qui sépare notre population en deux : on a la moitié de nos observations en-dessous, et la moitié au-dessus. Elle se calcule avec la fonction median.\n\nmedian(d$carat)\n\n[1] 0.7\n\n\nUne différence entre les deux indicateurs est que la médiane est beaucoup moins sensible aux valeurs “extrêmes” : on dit qu’elle est plus robuste.\n\n\n3.2.1.2 Indicateurs de dispersion\nLes indicateurs de dispersion permettent de mesurer si les valeurs sont plutôt regroupées ou au contraire plutôt dispersées.\nL’indicateur le plus simple est l’étendue de la distribution, qui décrit l’écart maximal observé entre les observations :\n\nmax(d$carat) - min(d$carat)\n\n[1] 4.81\n\n\nLes indicateurs de dispersion les plus utilisés sont la variance ou, de manière équivalente, l’écart-type (qui est égal à la racine carrée de la variance). On obtient la première avec la fonction var, et le second avec sd (abbréviation de standard deviation).\n\nvar(d$carat)\n\n[1] 0.2246867\n\n\n\nsd(d$carat)\n\n[1] 0.4740112\n\n\nPlus la variance ou l’écart-type sont élevés, plus les valeurs sont dispersées autour de la moyenne. À l’inverse, plus ils sont faibles et plus les valeurs sont regroupées.\nUne autre manière de mesurer la dispersion est de calculer les quartiles :\n\nle premier quartile est la valeur pour laquelle on a 25% des observations en dessous et 75% au dessus\nle deuxième quartile est la valeur pour laquelle on a 50% des observations en dessous et 50% au dessus (c’est donc la médiane)\nle troisième quartile est la valeur pour laquelle on a 75% des observations en dessous et 25% au dessus\n\nOn peut les calculer avec la fonction quantile :\n\n## Premier quartile\nquantile(d$carat, prob = 0.25)\n\n25% \n0.4 \n\n\n\n## Troisième quartile\nquantile(d$carat, prob = 0.75)\n\n 75% \n1.04 \n\n\nquantile prend deux arguments principaux : le vecteur dont on veut calculer le quantile, et un argument prob qui indique quel quantile on souhaite obtenir. prob prend une valeur entre 0 et 1 : 0.5 est la médiane, 0.25 le premier quartile, 0.1 le premier décile, etc.\nNotons enfin que la fonction summary permet d’obtenir d’un seul coup plusieurs indicateurs classiques :\n\nsummary(d$carat)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.2000  0.4000  0.7000  0.7979  1.0400  5.0100 \n\n\n\n\n3.2.1.3 Représentation graphique\nL’outil le plus utile pour étudier la distribution des valeurs d’une variable quantitative reste la représentation graphique.\nLa représentation la plus courante est sans doute l’histogramme. On peut l’obtenir avec la fonction hist.\n\nhist(d$carat)\n\n\n\n\n\n\n\n\nCette fonction n’a pas pour effet direct d’effectuer un calcul ou de nous renvoyer un résultat : elle génère un graphique qui va s’afficher dans l’onglet Plots de RStudio.\nOn peut personnaliser l’apparence de l’histogramme en ajoutant des arguments supplémentaires à la fonction hist. L’argument le plus important est breaks, qui permet d’indiquer le nombre de classes que l’on souhaite.\n\nhist(d$carat, breaks = 10)\n\n\n\n\n\n\n\n\n\nhist(d$carat, breaks = 70)\n\n\n\n\n\n\n\n\nLe choix d’un “bon” nombre de classes pour un histogramme n’est pas un problème simple : si on a trop peu de classes, on risque d’effacer quasiment toutes les variations, et si on en a trop on risque d’avoir trop de détails et de masquer les grandes tendances.\nLes arguments de hist permettent également de modifier la présentation du graphique. On peut ainsi changer la couleur des barres avec col, le titre avec main, les étiquettes des axes avec xlab et ylab, etc. :\n\nhist(d$carat, col = \"skyblue\",\n     main = \"Répartition des masses des diamants\",\n     xlab = \"Masse (en carat)\",\n     ylab = \"Effectif\")\n\n\n\n\n\n\n\n\nLa fonction hist fait partie des fonctions graphique de base de R. On verra plus en détail d’autres fonctions graphiques dans les prochaines semaines, consacrées à l’extension ggplot2, qui fait partie du tidyverse et qui permet la production et la personnalisation de graphiques complexes.\n\n\n\n3.2.2 Analyser une variable qualitative\nUne variable qualitative est une variable qui ne peut prendre qu’un nombre limité de valeurs, appelées modalités. Dans notre jeu de données on trouvera par exemple la découpe (cut), la couleur (color), la clareté (clarity).\nÀ noter qu’une variable qualitative peut tout-à-fait être numérique, et que certaines variables peuvent être traitées soit comme quantitatives, soit comme qualitatives.\n\n3.2.2.1 Tri à plat\nL’outil le plus utilisé pour représenter la répartition des valeurs d’une variable qualitative est le tri à plat : il s’agit simplement de compter, pour chacune des valeurs possibles de la variable (pour chacune des modalités), le nombre d’observations ayant cette valeur. Un tri à plat s’obtient sous R à l’aide de la fonction table.\n\ntable(d$cut)\n\n\n     Fair      Good Very Good   Premium     Ideal \n     1610      4906     12082     13791     21551 \n\n\nCe tableau nous indique donc pour chaque qualité de découpe, le nombre de diamants.\nUn tableau de ce type peut être affiché ou stocké dans un objet, et on peut à son tour lui appliquer des fonctions. Par exemple, la fonction sort permet de trier le tableau selon la valeur de l’effectif.\n\nd_cut &lt;- table(d$cut)\nsort(d_cut)\n\n\n     Fair      Good Very Good   Premium     Ideal \n     1610      4906     12082     13791     21551 \n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention, par défaut la fonction table n’affiche pas les valeurs manquantes (NA). Si on souhaite les inclure il faut utiliser l’argument useNA = \"always\", soit : table(d$cut, useNA = \"always\").\n\n\nÀ noter qu’on peut aussi appliquer summary à une variable qualitative. Le résultat est également le tri à plat de la variable, avec en plus le nombre de valeurs manquantes éventuelles.\n\nsummary(d$cut)\n\n     Fair      Good Very Good   Premium     Ideal \n     1610      4906     12082     13791     21551 \n\n\n\n\n3.2.2.2 Représentations graphiques\nOn peut représenter graphiquement le tri à plat d’une variable qualitative avec un diagramme en barres, obtenu avec la fonction barplot. Attention, contrairement à hist cette fonction ne s’applique pas directement à la variable mais au résultat du tri à plat de cette variable, calculé avec table. Il faut donc procéder en deux étapes.\n\nd_cut &lt;- table(d$cut)\nbarplot(d_cut)\n\n\n\n\n\n\n\n\nOn peut aussi trier le tri à plat avec la fonction sort avant de le représenter graphiquement, ce qui peut faciliter la lecture du graphique :\n\nbarplot(sort(d_cut))\n\n\n\n\n\n\n\n\nUne alternative au graphique en barres est le diagramme de Cleveland, qu’on peut obtenir avec la fonction dotchart. Celle-ci s’applique elle aussi au tri à plat de la variable calculé avec table.\n\ndotchart(table(d$cut))\n\n\n\n\n\n\n\n\nLà aussi, pour améliorer la lisibilité du graphique il est préférable de trier le tri à plat de la variable avant de le représenter :\n\ndotchart(sort(table(d$cut)))"
  },
  {
    "objectID": "SFC1018_Intro_R.html#exercices-1",
    "href": "SFC1018_Intro_R.html#exercices-1",
    "title": "Introduction à R",
    "section": "3.3 Exercices",
    "text": "3.3 Exercices\n\n3.3.1 Exercice 1\nCréer un nouveau script qui effectue les actions suivantes :\n\ncharger l’extension ggplot2\ncharger le jeu de données nommé mpg\ncopier le jeu de données dans un nouvel objet nommé df\nafficher les dimensions et la liste des variables de df\n\n\n\n3.3.2 Exercice 2\nOn souhaite étudier la consommation en ville et sur autoroute. Pour cela, affichez les principaux indicateurs les variables consernées : valeur minimale, maximale, moyenne, médiane et écart-type. Représentez ensuite leurs distributions par des histogrammes en 10 classes.\nCréez un nouvelle variable, conso, qui sera égale à la moyenne de la consommation en ville et de celle sur autoroute. Répondez aux mêmes questions à nouveau avec cette variable.\n\n\n3.3.3 Exercice 3\nOn s’intéresse maintenant aux marques des voitures, aux classes de voitures et à leur année de production. Faites un tri à plat pour les variables appropriées.\nReprésentez graphiquement ces effectifs à l’aide d’un graphique en barres."
  },
  {
    "objectID": "SFC1018_Intro_R.html#footnotes",
    "href": "SFC1018_Intro_R.html#footnotes",
    "title": "Introduction à R",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nEt permet de constater que pour R, un nombre est un vecteur à un seul élément.↩︎\nc est l’abbréviation de combine, son nom est très court car on l’utilise très souvent↩︎\nLa seule limite pour la taille d’un objet étant la mémoire vive (RAM) de la machine sur laquelle tourne la session R.↩︎\nLes différents types de variables seront décrits plus en détail un peu plus tard↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SFC1018",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "SFC1018_Manipulation_R.html",
    "href": "SFC1018_Manipulation_R.html",
    "title": "Manipulation de données",
    "section": "",
    "text": "dplyr est une extension facilitant le traitement et la manipulation de données contenues dans une ou plusieurs tables. Elle propose une syntaxe claire et cohérente, sous formes de verbes, pour la plupart des opérations de ce type.\ndplyr part du principe que les données sont organisées selon le modèle des tidy data (que nous verrons plus tard). Les fonctions de l’extension peuvent s’appliquer à des tableaux de type data.frame ou tibble, et elles retournent systématiquement un tibble.\nLe code présent dans ce document nécessite d’avoir installé dplyr.\n\n\ndplyr fait partie du coeur du tidyverse, elle est donc chargée automatiquement avec :\n\nlibrary(tidyverse)\n\nOn peut également la charger individuellement.\n\nlibrary(dplyr)\n\nDans ce qui suit on va utiliser le jeu de données nycflights13, contenu dans l’extension du même nom (qu’il faut donc avoir installé). Celui-ci correspond aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. Il a la particularité d’être réparti en trois tables :\n\nflights contient des informations sur les vols : date, départ, destination, horaires, retard…\nairports contient des informations sur les aéroports\nairlines contient des données sur les compagnies aériennes\n\nOn va charger les trois tables du jeu de données :\n\nlibrary(nycflights13)\n## Chargement des trois tables\ndata(flights)\ndata(airports)\ndata(airlines)\n\nTrois objets correspondant aux trois tables ont dû apparaître dans votre environnement.\n\n\n\nLa manipulation de données avec dplyr se fait en utilisant un nombre réduit de verbes, qui correspondent chacun à une action différente appliquée à un tableau de données.\n\n\nLe verbe slice sélectionne des lignes du tableau selon leur position. On lui passe un chiffre ou un vecteur de chiffres.\nSi on souhaite sélectionner la 345e ligne du tableau airports :\n\nslice(airports, 345)\n\n# A tibble: 1 × 8\n  faa   name                lat   lon   alt    tz dst   tzone            \n  &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            \n1 CYF   Chefornak Airport  60.1 -164.    40    -9 A     America/Anchorage\n\n\nSi on veut sélectionner les 5 premières lignes :\n\nslice(airports, 1:5)\n\n# A tibble: 5 × 8\n  faa   name                            lat   lon   alt    tz dst   tzone       \n  &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       \n1 04G   Lansdowne Airport              41.1 -80.6  1044    -5 A     America/New…\n2 06A   Moton Field Municipal Airport  32.5 -85.7   264    -6 A     America/Chi…\n3 06C   Schaumburg Regional            42.0 -88.1   801    -6 A     America/Chi…\n4 06N   Randall Airport                41.4 -74.4   523    -5 A     America/New…\n5 09J   Jekyll Island Airport          31.1 -81.4    11    -5 A     America/New…\n\n\nslice propose plusieurs variantes utiles, dont slice_head et slice_tail, qui permettent de sélectionner les premières ou les dernières lignes du tableau (on peut spécifier le nombre de lignes souhaitées avec n, ou la proportion avec prop).\n\nslice_tail(airports, n = 3)\n\n# A tibble: 3 × 8\n  faa   name                        lat   lon   alt    tz dst   tzone           \n  &lt;chr&gt; &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n1 ZWI   Wilmington Amtrak Station  39.7 -75.6     0    -5 A     America/New_York\n2 ZWU   Washington Union Station   38.9 -77.0    76    -5 A     America/New_York\n3 ZYP   Penn Station               40.8 -74.0    35    -5 A     America/New_York\n\n\n\nslice_head(airlines, prop = 0.2)\n\n# A tibble: 3 × 2\n  carrier name                  \n  &lt;chr&gt;   &lt;chr&gt;                 \n1 9E      Endeavor Air Inc.     \n2 AA      American Airlines Inc.\n3 AS      Alaska Airlines Inc.  \n\n\nAutres variantes utiles, slice_min et slice_max permettent de sélectionner les lignes avec les valeurs les plus grandes ou les plus petite d’une variable donnée. Ainsi, la commande suivante sélectionne le vol ayant le retard au départ le plus faible.\n\nslice_min(flights, dep_delay)\n\n# A tibble: 1 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013    12     7     2040           2123       -43       40           2352\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut aussi spécifier le nombre de lignes souhaitées, par exemple la commande suivante retourne les 5 aéroports avec l’altitude la plus élevée (en cas de valeurs ex-aequo, il se peut que le nombre de lignes retournées soit plus élevé que celui demandé).\n\nslice_max(airports, alt, n = 5)\n\n# A tibble: 5 × 8\n  faa   name                              lat   lon   alt    tz dst   tzone     \n  &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n1 TEX   Telluride                        38.0 -108.  9078    -7 A     America/D…\n2 TVL   Lake Tahoe Airport               38.9 -120.  8544    -8 A     America/L…\n3 ASE   Aspen Pitkin County Sardy Field  39.2 -107.  7820    -7 A     America/D…\n4 GUC   Gunnison - Crested Butte         38.5 -107.  7678    -7 A     America/D…\n5 BCE   Bryce Canyon                     37.7 -112.  7590    -7 A     America/D…\n\n\n\n\n\nfilter sélectionne des lignes d’une table selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie TRUE (vrai) sont conservées. Pour plus d’informations sur les tests et leur syntaxe, voir ?@sec-tests.\nPar exemple, si on veut sélectionner les vols du mois de janvier, on peut filtrer sur la variable month de la manière suivante :\n\nfilter(flights, month == 1)\n\n# A tibble: 27,004 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 26,994 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut uniquement les vols avec un retard au départ (variable dep_delay) compris entre 10 et 15 minutes :\n\nfilter(flights, dep_delay &gt;= 10 & dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on passe plusieurs arguments à filter, celui-ci rajoute automatiquement une condition et entre les conditions. La commande précédente peut donc être écrite de la manière suivante, avec le même résultat :\n\nfilter(flights, dep_delay &gt;= 10, dep_delay &lt;= 15)\n\nOn peut également placer des fonctions dans les tests, qui nous permettent par exemple de sélectionner les vols ayant une distance supérieure à la distance médiane :\n\nfilter(flights, distance &gt; median(distance))\n\n# A tibble: 167,133 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      555            600        -5      913            854\n 6  2013     1     1      557            600        -3      838            846\n 7  2013     1     1      558            600        -2      849            851\n 8  2013     1     1      558            600        -2      853            856\n 9  2013     1     1      558            600        -2      924            917\n10  2013     1     1      558            600        -2      923            937\n# ℹ 167,123 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nselect permet de sélectionner des colonnes d’un tableau de données. Ainsi, si on veut extraire les colonnes lat et lon du tableau airports :\n\nselect(airports, lat, lon)\n\n# A tibble: 1,458 × 2\n     lat    lon\n   &lt;dbl&gt;  &lt;dbl&gt;\n 1  41.1  -80.6\n 2  32.5  -85.7\n 3  42.0  -88.1\n 4  41.4  -74.4\n 5  31.1  -81.4\n 6  36.4  -82.2\n 7  41.5  -84.5\n 8  42.9  -76.8\n 9  39.8  -76.6\n10  48.1 -123. \n# ℹ 1,448 more rows\n\n\nSi on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée :\n\nselect(airports, -lat, -lon)\n\n# A tibble: 1,458 × 6\n   faa   name                             alt    tz dst   tzone              \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              \n 1 04G   Lansdowne Airport               1044    -5 A     America/New_York   \n 2 06A   Moton Field Municipal Airport    264    -6 A     America/Chicago    \n 3 06C   Schaumburg Regional              801    -6 A     America/Chicago    \n 4 06N   Randall Airport                  523    -5 A     America/New_York   \n 5 09J   Jekyll Island Airport             11    -5 A     America/New_York   \n 6 0A9   Elizabethton Municipal Airport  1593    -5 A     America/New_York   \n 7 0G6   Williams County Airport          730    -5 A     America/New_York   \n 8 0G7   Finger Lakes Regional Airport    492    -5 A     America/New_York   \n 9 0P2   Shoestring Aviation Airfield    1000    -5 U     America/New_York   \n10 0S9   Jefferson County Intl            108    -8 A     America/Los_Angeles\n# ℹ 1,448 more rows\n\n\nselect comprend toute une série de fonctions facilitant la sélection de colonnes multiples. Par exemple, starts_with, ends_width, contains ou matches permettent d’exprimer des conditions sur les noms de variables.\n\nselect(flights, starts_with(\"dep_\"))\n\n# A tibble: 336,776 × 2\n   dep_time dep_delay\n      &lt;int&gt;     &lt;dbl&gt;\n 1      517         2\n 2      533         4\n 3      542         2\n 4      544        -1\n 5      554        -6\n 6      554        -4\n 7      555        -5\n 8      557        -3\n 9      557        -3\n10      558        -2\n# ℹ 336,766 more rows\n\n\nLa syntaxe colonne1:colonne2 permet de sélectionner toutes les colonnes situées entre colonne1 et colonne2 incluses1.\n\nselect(flights, year:day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\nselect propose de nombreuses autres possibilités de sélection qui sont décrites dans la documentation de l’extension tidyselect.\nUne variante de select est rename2, qui permet de renommer des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom. Ainsi, si on veut renommer les colonnes lon et lat de airports en longitude et latitude :\n\nrename(airports, longitude = lon, latitude = lat)\n\n# A tibble: 1,458 × 8\n   faa   name                         latitude longitude   alt    tz dst   tzone\n   &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n 1 04G   Lansdowne Airport                41.1     -80.6  1044    -5 A     Amer…\n 2 06A   Moton Field Municipal Airpo…     32.5     -85.7   264    -6 A     Amer…\n 3 06C   Schaumburg Regional              42.0     -88.1   801    -6 A     Amer…\n 4 06N   Randall Airport                  41.4     -74.4   523    -5 A     Amer…\n 5 09J   Jekyll Island Airport            31.1     -81.4    11    -5 A     Amer…\n 6 0A9   Elizabethton Municipal Airp…     36.4     -82.2  1593    -5 A     Amer…\n 7 0G6   Williams County Airport          41.5     -84.5   730    -5 A     Amer…\n 8 0G7   Finger Lakes Regional Airpo…     42.9     -76.8   492    -5 A     Amer…\n 9 0P2   Shoestring Aviation Airfield     39.8     -76.6  1000    -5 U     Amer…\n10 0S9   Jefferson County Intl            48.1    -123.    108    -8 A     Amer…\n# ℹ 1,448 more rows\n\n\nSi les noms de colonnes comportent des espaces ou des caractères spéciaux, on peut les entourer de guillemets (\") ou de quotes inverses (`) :\n\ntmp &lt;- rename(\n    flights,\n    \"retard départ\" = dep_delay,\n    \"retard arrivée\" = arr_delay\n)\nselect(tmp, `retard départ`, `retard arrivée`)\n\n# A tibble: 336,776 × 2\n   `retard départ` `retard arrivée`\n             &lt;dbl&gt;            &lt;dbl&gt;\n 1               2               11\n 2               4               20\n 3               2               33\n 4              -1              -18\n 5              -6              -25\n 6              -4               12\n 7              -5               19\n 8              -3              -14\n 9              -3               -8\n10              -2                8\n# ℹ 336,766 more rows\n\n\n\n\n\narrange réordonne les lignes d’un tableau selon une ou plusieurs colonnes.\nAinsi, si on veut trier le tableau flights selon le retard au départ croissant :\n\narrange(flights, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013    12     7     2040           2123       -43       40           2352\n 2  2013     2     3     2022           2055       -33     2240           2338\n 3  2013    11    10     1408           1440       -32     1549           1559\n 4  2013     1    11     1900           1930       -30     2233           2243\n 5  2013     1    29     1703           1730       -27     1947           1957\n 6  2013     8     9      729            755       -26     1002            955\n 7  2013    10    23     1907           1932       -25     2143           2143\n 8  2013     3    30     2030           2055       -25     2213           2250\n 9  2013     3     2     1431           1455       -24     1601           1631\n10  2013     5     5      934            958       -24     1225           1309\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut trier selon plusieurs colonnes. Par exemple selon le mois, puis selon le retard au départ :\n\narrange(flights, month, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1    11     1900           1930       -30     2233           2243\n 2  2013     1    29     1703           1730       -27     1947           1957\n 3  2013     1    12     1354           1416       -22     1606           1650\n 4  2013     1    21     2137           2159       -22     2232           2316\n 5  2013     1    20      704            725       -21     1025           1035\n 6  2013     1    12     2050           2110       -20     2310           2355\n 7  2013     1    12     2134           2154       -20        4             50\n 8  2013     1    14     2050           2110       -20     2329           2355\n 9  2013     1     4     2140           2159       -19     2241           2316\n10  2013     1    11     1947           2005       -18     2209           2230\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut trier selon une colonne par ordre décroissant, on lui applique la fonction desc() :\n\narrange(flights, desc(dep_delay))\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nCombiné avec slice, arrange permet par exemple de sélectionner les trois vols ayant eu le plus de retard :\n\ntmp &lt;- arrange(flights, desc(dep_delay))\nslice(tmp, 1:3)\n\n# A tibble: 3 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013     1     9      641            900      1301     1242           1530\n2  2013     6    15     1432           1935      1137     1607           2120\n3  2013     1    10     1121           1635      1126     1239           1810\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nmutate permet de créer de nouvelles colonnes dans le tableau de données, en général à partir de variables existantes.\nPar exemple, la table flights contient la durée du vol en minutes.. Si on veut créer une nouvelle variable duree_h avec cette durée en heures, on peut faire :\n\nflights &lt;- mutate(flights, duree_h = air_time / 60)\n\nselect(flights, air_time, duree_h)\n\n# A tibble: 336,776 × 2\n   air_time duree_h\n      &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78 \n 2      227   3.78 \n 3      160   2.67 \n 4      183   3.05 \n 5      116   1.93 \n 6      150   2.5  \n 7      158   2.63 \n 8       53   0.883\n 9      140   2.33 \n10      138   2.3  \n# ℹ 336,766 more rows\n\n\nOn peut créer plusieurs nouvelles colonnes en une seule commande, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. L’exemple suivant convertit d’abord la durée en heures dans une variable duree_h et la distance en kilomètres dans une variable distance_km, puis utilise ces nouvelles colonnes pour calculer la vitesse en km/h.\n\nflights &lt;- mutate(\n    flights,\n    duree_h = air_time / 60,\n    distance_km = distance / 0.62137,\n    vitesse = distance_km / duree_h\n)\n\nselect(flights, air_time, duree_h, distance, distance_km, vitesse)\n\n# A tibble: 336,776 × 5\n   air_time duree_h distance distance_km vitesse\n      &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78      1400       2253.    596.\n 2      227   3.78      1416       2279.    602.\n 3      160   2.67      1089       1753.    657.\n 4      183   3.05      1576       2536.    832.\n 5      116   1.93       762       1226.    634.\n 6      150   2.5        719       1157.    463.\n 7      158   2.63      1065       1714.    651.\n 8       53   0.883      229        369.    417.\n 9      140   2.33       944       1519.    651.\n10      138   2.3        733       1180.    513.\n# ℹ 336,766 more rows\n\n\nÀ noter que mutate est évidemment parfaitement compatible avec les fonctions vues ?@sec-vectorfactor sur les recodages : fct_recode, ifelse, case_when…\nL’avantage d’utiliser mutate est double. D’abord il permet d’éviter d’avoir à saisir le nom du tableau de données dans les conditions d’un ifelse ou d’un case_when :\n\nflights &lt;- mutate(\n    flights,\n    type_retard = case_when(\n        dep_delay &gt; 0 & arr_delay &gt; 0 ~ \"Retard départ et arrivée\",\n        dep_delay &gt; 0 & arr_delay &lt;= 0 ~ \"Retard départ\",\n        dep_delay &lt;= 0 & arr_delay &gt; 0 ~ \"Retard arrivée\",\n        TRUE ~ \"Aucun retard\"\n    )\n)\n\nEnsuite, il permet aussi d’intégrer ces recodages dans un pipeline de traitement de données, concept présenté dans la section suivante.\n\n\n\n\nQuand on manipule un tableau de données, il est très fréquent d’enchaîner plusieurs opérations. On va par exemple extraire une sous-population avec filter, sélectionner des colonnes avec select puis trier selon une variable avec arrange, etc.\nQuand on veut enchaîner des opérations, on peut le faire de différentes manières. La première est d’effectuer toutes les opérations en une fois en les “emboîtant” :\n\narrange(select(filter(flights, dest == \"LAX\"), dep_delay, arr_delay), dep_delay)\n\nCette notation a plusieurs inconvénients :\n\nelle est peu lisible\nles opérations apparaissent dans l’ordre inverse de leur réalisation. Ici on effectue d’abord le filter, puis le select, puis le arrange, alors qu’à la lecture du code c’est le arrange qui apparaît en premier.\nIl est difficile de voir quel paramètre se rapporte à quelle fonction\n\nUne autre manière de faire est d’effectuer les opérations les unes après les autres, en stockant les résultats intermédiaires dans un objet temporaire :\n\ntmp &lt;- filter(flights, dest == \"LAX\")\ntmp &lt;- select(tmp, dep_delay, arr_delay)\narrange(tmp, dep_delay)\n\nC’est nettement plus lisible, l’ordre des opérations est le bon, et les paramètres sont bien rattachés à leur fonction. Par contre, ça reste un peu “verbeux”, et on crée un objet temporaire tmp dont on n’a pas réellement besoin.\nPour simplifier et améliorer encore la lisibilité du code, on va utiliser un nouvel opérateur, baptisé pipe3. Le pipe se note %&gt;%, et son fonctionnement est le suivant : si j’exécute expr %&gt;% f, alors le résultat de l’expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr).\nAinsi les deux expressions suivantes sont rigoureusement équivalentes :\n\nfilter(flights, dest == \"LAX\")\n\n\nflights %&gt;% filter(dest == \"LAX\")\n\nCe qui est particulièrement intéressant, c’est qu’on va pouvoir enchaîner les pipes. Plutôt que d’écrire :\n\nselect(filter(flights, dest == \"LAX\"), dep_delay, arr_delay)\n\nOn va pouvoir faire :\n\nflights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay)\n\nÀ chaque fois, le résultat de ce qui se trouve à gauche du pipe est passé comme premier argument à ce qui se trouve à droite : on part de l’objet flights, qu’on passe comme premier argument à la fonction filter, puis on passe le résultat de ce filter comme premier argument du select.\nLe résultat final est le même avec les deux syntaxes, mais avec le pipe l’ordre des opérations correspond à l’ordre naturel de leur exécution, et on n’a pas eu besoin de créer d’objet intermédiaire.\nSi la liste des fonctions enchaînées est longue, on peut les répartir sur plusieurs lignes à condition que l’opérateur %&gt;% soit en fin de ligne :\n\nflights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\n\n\n\n\n\n\nNote\n\n\n\nOn appelle une suite d’instructions de ce type un pipeline.\n\n\nÉvidemment, il est naturel de vouloir récupérer le résultat final d’un pipeline pour le stocker dans un objet. On peut stocker le résultat du pipeline ci-dessus dans un nouveau tableau delay_la de la manière suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\nDans ce cas, delay_la contiendra le tableau final, obtenu après application des trois instructions filter, select et arrange.\nCette notation n’est pas forcément très intuitive au départ : il faut bien comprendre que c’est le résultat final, une fois application de toutes les opérations du pipeline, qui est renvoyé et stocké dans l’objet en début de ligne.\nUne manière de le comprendre peut être de voir que la notation suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay)\n\nest équivalente à :\n\ndelay_la &lt;- (flights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay))\n\n\n\n\n\n\n\nNote\n\n\n\nL’utilisation du pipe n’est pas obligatoire, mais elle rend les scripts plus lisibles et plus rapides à saisir. On l’utilisera donc dans ce qui suit.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nDepuis la version 4.1, R propose un pipe “natif”, qui fonctionne partout, même si on n’utilise pas les extensions du tidyverse. Celui-ci est noté |&gt;.\nIl s’utilise de la même manière que %&gt;% :\nflights |&gt; filter(dest == \"LAX\")\nCe pipe natif est à la fois un peu plus rapide et un peu moins souple. Par exemple, il est possible avec %&gt;% d’appeler une fonction sans mettre de parenthèses :\ndf %&gt;% View\nCe n’est pas possible d’omettre les parenthèses avec |&gt;, on doit obligatoirement faire :\ndf |&gt; View()\nDans la suite de ce document on privilégiera (pour l’instant) le pipe du tidyverse %&gt;%, pour des raisons de compatibilité avec des versions de R moins récentes.\n\n\n\n\n\n\n\nUn élément très important de dplyr est la fonction group_by. Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois :\n\nflights %&gt;% group_by(month)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPar défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups dans l’affichage du résultat. Mais à partir du moment où des groupes ont été définis, les verbes comme slice, mutate ou summarise vont en tenir compte lors de leurs opérations.\nPar exemple, si on applique slice à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe. Ainsi la commande suivante affiche le premier vol de chaque mois, selon leur ordre d’apparition dans le tableau :\n\nflights %&gt;% group_by(month) %&gt;% slice(1)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     2     1      456            500        -4      652            648\n 3  2013     3     1        4           2159       125      318             56\n 4  2013     4     1      454            500        -6      636            640\n 5  2013     5     1        9           1655       434      308           2020\n 6  2013     6     1        2           2359         3      341            350\n 7  2013     7     1        1           2029       212      236           2359\n 8  2013     8     1       12           2130       162      257             14\n 9  2013     9     1        9           2359        10      343            340\n10  2013    10     1      447            500       -13      614            648\n11  2013    11     1        5           2359         6      352            345\n12  2013    12     1       13           2359        14      446            445\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPlus utile, en utilisant une variante comme slice_min ou slice_max, on peut sélectionner les lignes ayant les valeurs les plus grandes ou les plus petites pour chaque groupe. Par exemple la commande suivant sélectionne, pour chaque mois de l’année, le vol ayant eu le retard le plus important.\n\nflights %&gt;% group_by(month) %&gt;% slice_max(dep_delay)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     2    10     2243            830       853      100           1106\n 3  2013     3    17     2321            810       911      135           1020\n 4  2013     4    10     1100           1900       960     1342           2211\n 5  2013     5     3     1133           2055       878     1250           2215\n 6  2013     6    15     1432           1935      1137     1607           2120\n 7  2013     7    22      845           1600      1005     1044           1815\n 8  2013     8     8     2334           1454       520      120           1710\n 9  2013     9    20     1139           1845      1014     1457           2210\n10  2013    10    14     2042            900       702     2255           1127\n11  2013    11     3      603           1645       798      829           1913\n12  2013    12     5      756           1700       896     1058           2020\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nIdem pour mutate : les opérations appliquées lors du calcul des valeurs des nouvelles colonnes sont appliquées groupe de lignes par groupe de lignes. Dans l’exemple suivant, on ajoute une nouvelle colonne qui contient le retard moyen pour chaque compagnie aérienne. Cette valeur est donc différente d’une compagnie à une autre, mais identique pour tous les vols d’une même compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(mean_delay_carrier = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  select(dep_delay, mean_delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 3\n# Groups:   carrier [16]\n   carrier dep_delay mean_delay_carrier\n   &lt;chr&gt;       &lt;dbl&gt;              &lt;dbl&gt;\n 1 UA              2              12.1 \n 2 UA              4              12.1 \n 3 AA              2               8.59\n 4 B6             -1              13.0 \n 5 DL             -6               9.26\n 6 UA             -4              12.1 \n 7 B6             -5              13.0 \n 8 EV             -3              20.0 \n 9 B6             -3              13.0 \n10 AA             -2               8.59\n# ℹ 336,766 more rows\n\n\nCeci peut permettre, par exemple, de déterminer si un retard donné est supérieur ou inférieur au retard médian de la compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(\n      median_delay = median(dep_delay, na.rm = TRUE),\n      delay_carrier = ifelse(\n          dep_delay &gt; median_delay,\n          \"Supérieur\",\n          \"Inférieur ou égal\"\n      )\n  ) %&gt;%\n  select(dep_delay, median_delay, delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 4\n# Groups:   carrier [16]\n   carrier dep_delay median_delay delay_carrier    \n   &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;            \n 1 UA              2            0 Supérieur        \n 2 UA              4            0 Supérieur        \n 3 AA              2           -3 Supérieur        \n 4 B6             -1           -1 Inférieur ou égal\n 5 DL             -6           -2 Inférieur ou égal\n 6 UA             -4            0 Inférieur ou égal\n 7 B6             -5           -1 Inférieur ou égal\n 8 EV             -3           -1 Inférieur ou égal\n 9 B6             -3           -1 Inférieur ou égal\n10 AA             -2           -3 Supérieur        \n# ℹ 336,766 more rows\n\n\ngroup_by peut aussi être utile avec filter, par exemple pour sélectionner pour chaque mois les vols avec un retard au départ plus élevé que le retard moyen ce mois-ci.\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  filter(dep_delay &gt;= mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 78,164 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      632            608        24      740            728\n 4  2013     1     1      732            645        47     1011            941\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      743            730        13     1059           1056\n 7  2013     1     1      749            710        39      939            850\n 8  2013     1     1      811            630       101     1047            830\n 9  2013     1     1      826            715        71     1136           1045\n10  2013     1     1      848           1835       853     1001           1950\n# ℹ 78,154 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention : la clause group_by marche pour les verbes déjà vus précédemment, sauf pour arrange, qui par défaut trie la table sans tenir compte des groupes. Pour obtenir un tri par groupe, il faut lui ajouter l’argument .by_group = TRUE.\n\n\nOn peut voir la différence en comparant les deux résultats suivants :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay))\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay), .by_group = TRUE)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     1    10     1121           1635      1126     1239           1810\n 3  2013     1     1      848           1835       853     1001           1950\n 4  2013     1    13     1809            810       599     2054           1042\n 5  2013     1    16     1622            800       502     1911           1054\n 6  2013     1    23     1551            753       478     1812           1006\n 7  2013     1    10     1525            900       385     1713           1039\n 8  2013     1     1     2343           1724       379      314           1938\n 9  2013     1     2     2131           1512       379     2340           1741\n10  2013     1     7     2021           1415       366     2332           1724\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\nsummarise permet d’agréger les lignes du tableau en effectuant une opération “résumée” sur une ou plusieurs colonnes. Par exemple, si on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights :\n\nflights %&gt;%\n  summarise(\n      retard_dep = mean(dep_delay, na.rm = TRUE),\n      retard_arr = mean(arr_delay, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 2\n  retard_dep retard_arr\n       &lt;dbl&gt;      &lt;dbl&gt;\n1       12.6       6.90\n\n\nCette fonction est en général utilisée avec group_by, puisqu’elle permet du coup d’agréger et résumer les lignes du tableau groupe par groupe. Si on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  summarise(\n      max_delay = max(dep_delay, na.rm = TRUE),\n      min_delay = min(dep_delay, na.rm = TRUE),\n      mean_delay = mean(dep_delay, na.rm = TRUE)\n  )\n\n# A tibble: 12 × 4\n   month max_delay min_delay mean_delay\n   &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n 1     1      1301       -30      10.0 \n 2     2       853       -33      10.8 \n 3     3       911       -25      13.2 \n 4     4       960       -21      13.9 \n 5     5       878       -24      13.0 \n 6     6      1137       -21      20.8 \n 7     7      1005       -22      21.7 \n 8     8       520       -26      12.6 \n 9     9      1014       -24       6.72\n10    10       702       -25       6.24\n11    11       798       -32       5.44\n12    12       896       -43      16.6 \n\n\nsummarise dispose d’un opérateur spécial, n(), qui retourne le nombre de lignes du groupe. Ainsi si on veut le nombre de vols par destination, on peut utiliser :\n\nflights %&gt;%\n  group_by(dest) %&gt;%\n  summarise(nb = n())\n\n# A tibble: 105 × 2\n   dest     nb\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\nn() peut aussi être utilisée avec filter et mutate.\nÀ noter que quand on veut compter le nombre de lignes par groupe, il est plus simple d’utiliser directement la fonction count. Ainsi le code suivant est identique au précédent :\n\nflights %&gt;%\n  count(dest)\n\n# A tibble: 105 × 2\n   dest      n\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\n\n\n\nOn peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du group_by. Le pipeline suivant calcule le retard moyen au départ pour chaque mois et pour chaque destination, et trie le résultat par retard décroissant :\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  arrange(desc(retard_moyen))\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,113 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1    12 BZN           75  \n 2     7 TUL           72.6\n 3     3 DSM           71.0\n 4     7 CAE           69.4\n 5    11 SBN           67.5\n 6     7 BHM           64.6\n 7     7 TYS           60.6\n 8     6 BHM           57.2\n 9     1 TUL           55.2\n10     1 SAV           54.8\n# ℹ 1,103 more rows\n\n\nOn peut également utiliser count sur plusieurs variables. Les commandes suivantes comptent le nombre de vols pour chaque couple aéroport de départ / aéroport d’arrivée, et trie le résultat par nombre de vols décroissant. Ici la colonne qui contient le nombre de vols, créée par count, s’appelle n par défaut :\n\nflights %&gt;%\n  count(origin, dest) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 224 × 3\n   origin dest      n\n   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n 1 JFK    LAX   11262\n 2 LGA    ATL   10263\n 3 LGA    ORD    8857\n 4 JFK    SFO    8204\n 5 LGA    CLT    6168\n 6 EWR    ORD    6100\n 7 JFK    BOS    5898\n 8 LGA    MIA    5781\n 9 JFK    MCO    5464\n10 EWR    BOS    5327\n# ℹ 214 more rows\n\n\nOn peut utiliser plusieurs opérations de groupage dans le même pipeline. Ainsi, si on souhaite déterminer le couple aéroport de départ / aéroport d’arrivée ayant le retard moyen au départ le plus élevé pour chaque mois de l’année, on devra procéder en deux étapes :\n\nd’abord grouper selon mois, aéroports d’origine et d’arrivée pour calculer le retard moyen\npuis grouper uniquement selon le mois pour sélectionner le mois avec le retard moyen maximal.\n\nAu final, on obtient le code suivant :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  group_by(month) %&gt;%\n  slice_max(retard_moyen)\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 12 × 4\n# Groups:   month [12]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    TUL           55.2\n 2     2 EWR    DSM           48.6\n 3     3 EWR    DSM           71.0\n 4     4 EWR    OKC           47.0\n 5     5 EWR    TYS           60.6\n 6     6 EWR    TYS           68.2\n 7     7 EWR    CAE           81.5\n 8     8 LGA    GSO           50.1\n 9     9 LGA    MSN           24.7\n10    10 EWR    CAE           50.1\n11    11 LGA    SBN           67.5\n12    12 EWR    BZN           75  \n\n\n\n\n\nLorsqu’on effectue un group_by suivi d’un summarise, le tableau résultat est automatiquement dégroupé de la dernière variable de regroupement. Ainsi le tableau généré par le code suivant est seulement groupé par month et origin :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE))\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 2,313 × 4\n# Groups:   month, origin [36]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    ALB          41.4 \n 2     1 EWR    ATL           8.07\n 3     1 EWR    AUS           6.67\n 4     1 EWR    AVL          25.5 \n 5     1 EWR    BDL          21.1 \n 6     1 EWR    BNA          16.3 \n 7     1 EWR    BOS           8.99\n 8     1 EWR    BQN          12.3 \n 9     1 EWR    BTV          20.5 \n10     1 EWR    BUF          23.1 \n# ℹ 2,303 more rows\n\n\ndplyr nous le signale d’ailleurs via un message d’avertissement : summarise() has grouped output by 'month', 'origin'.\nCe dégroupage progressif peut permettre “d’enchaîner” les opérations groupées. Dans l’exemple suivant on calcule le retard moyen au départ par destination et on conserve les trois retards les plus importants pour chaque mois.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 36 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1     1 TUL           55.2\n 2     1 SAV           54.8\n 3     1 DSM           42.2\n 4     2 DSM           48.6\n 5     2 TUL           34.2\n 6     2 GSP           32.4\n 7     3 DSM           71.0\n 8     3 PVD           47.5\n 9     3 CAE           46.9\n10     4 OKC           47.0\n# ℹ 26 more rows\n\n\nOn peut à tout moment “dégrouper” un tableau à l’aide de ungroup. C’est nécessaire, dans l’exemple précédent, si on veut seulement récupérer les trois retards les plus importants pour l’ensemble des couples mois / destination.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 3 × 3\n  month dest  retard_moyen\n  &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n1    12 BZN           75  \n2     7 TUL           72.6\n3     3 DSM           71.0\n\n\nOn peut aussi spécifier précisément le comportement de dégroupage de summarise en lui fournissant un argument supplémentaire .groups qui peut prendre notamment les valeurs suivantes :\n\n\"drop_last\" : dégroupe seulement de la dernière variable de groupage\n\"drop\" : dégroupe totalement le tableau résultat (équivaut à l’application d’un ungroup)\n\"keep\" : conserve toutes les variables de groupage\n\nCe concept de dégroupage successif peut être un peu déroutant de prime abord. Il est donc utile de faire attention aux avertissements affichés par ces opérations, et il ne faut pas hésiter à ajouter un ungroup en fin de pipeline si on sait qu’on ne souhaite pas utiliser les groupes encore existants par la suite.\nÀ noter que la fonction count, de son côté, renvoie un tableau non groupé.\n\nflights %&gt;%\n  count(month, dest)\n\n# A tibble: 1,113 × 3\n   month dest      n\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n 1     1 ALB      64\n 2     1 ATL    1396\n 3     1 AUS     169\n 4     1 AVL       2\n 5     1 BDL      37\n 6     1 BHM      25\n 7     1 BNA     399\n 8     1 BOS    1245\n 9     1 BQN      93\n10     1 BTV     223\n# ℹ 1,103 more rows\n\n\n\n\n\n\ndplyr contient beaucoup d’autres fonctions utiles pour la manipulation de données.\n\n\nCe verbe permet de sélectionner aléatoirement un nombre de lignes (avec l’argument n) ou une fraction des lignes (avec l’argument prop) d’un tableau.\nAinsi si on veut choisir 5 lignes au hasard dans le tableau airports :\n\nairports %&gt;% slice_sample(n = 5)\n\n# A tibble: 5 × 8\n  faa   name                               lat    lon   alt    tz dst   tzone   \n  &lt;chr&gt; &lt;chr&gt;                            &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   \n1 SME   Lake Cumberland Regional Airport  37.1  -84.6   927    -5 A     America…\n2 CVX   Charlevoix Municipal Airport      45.3  -85.3   669    -5 A     America…\n3 KKH   Kongiganak Airport                60.0 -163.     30    -9 A     America…\n4 MCI   Kansas City Intl                  39.3  -94.7  1026    -6 A     America…\n5 DET   Coleman A Young Muni              42.4  -83.0   626    -5 A     America…\n\n\nSi on veut tirer au hasard 10% des lignes de flights :\n\nflights %&gt;% slice_sample(prop = 0.1)\n\n# A tibble: 33,677 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     2    10      746            745         1     1211           1234\n 2  2013    12    11     1047           1047         0     1248           1245\n 3  2013     3     8       NA           1729        NA       NA           2049\n 4  2013     2    25     1249           1300       -11     1442           1450\n 5  2013    10     4      803            810        -7     1052           1119\n 6  2013    10    10     1515           1454        21     1716           1712\n 7  2013    11    17     1150           1151        -1     1514           1459\n 8  2013    10    24      634            637        -3      922            923\n 9  2013     3    16      825            830        -5     1041           1106\n10  2013     7    14      112           2359        73      447            340\n# ℹ 33,667 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nCes fonctions sont utiles notamment pour faire de “l’échantillonnage” en tirant au hasard un certain nombre d’observations du tableau.\n\n\n\nlead et lag permettent de décaler les observations d’une variable d’un cran vers l’arrière (pour lead) ou vers l’avant (pour lag).\n\nlead(1:5)\n\n[1]  2  3  4  5 NA\n\nlag(1:5)\n\n[1] NA  1  2  3  4\n\n\nCeci peut être utile pour des données de type “séries temporelles”. Par exemple, on peut facilement calculer l’écart entre le retard au départ de chaque vol et celui du vol précédent :\n\nflights %&gt;%\n  mutate(\n      dep_delay_prev = lag(dep_delay),\n      dep_delay_diff = dep_delay - dep_delay_prev\n  ) %&gt;%\n  select(dep_delay_prev, dep_delay, dep_delay_diff)\n\n# A tibble: 336,776 × 3\n   dep_delay_prev dep_delay dep_delay_diff\n            &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;\n 1             NA         2             NA\n 2              2         4              2\n 3              4         2             -2\n 4              2        -1             -3\n 5             -1        -6             -5\n 6             -6        -4              2\n 7             -4        -5             -1\n 8             -5        -3              2\n 9             -3        -3              0\n10             -3        -2              1\n# ℹ 336,766 more rows\n\n\n\n\n\ndistinct filtre les lignes du tableau pour ne conserver que les lignes distinctes, en supprimant toutes les lignes en double.\n\nflights %&gt;%\n  select(day, month) %&gt;%\n  distinct()\n\n# A tibble: 365 × 2\n     day month\n   &lt;int&gt; &lt;int&gt;\n 1     1     1\n 2     2     1\n 3     3     1\n 4     4     1\n 5     5     1\n 6     6     1\n 7     7     1\n 8     8     1\n 9     9     1\n10    10     1\n# ℹ 355 more rows\n\n\nOn peut lui spécifier une liste de variables : dans ce cas, pour toutes les observations ayant des valeurs identiques pour les variables en question, distinct ne conservera que la première d’entre elles.\n\nflights %&gt;%\n  distinct(month, day)\n\n# A tibble: 365 × 2\n   month   day\n   &lt;int&gt; &lt;int&gt;\n 1     1     1\n 2     1     2\n 3     1     3\n 4     1     4\n 5     1     5\n 6     1     6\n 7     1     7\n 8     1     8\n 9     1     9\n10     1    10\n# ℹ 355 more rows\n\n\nL’option .keep_all permet, dans l’opération précédente, de conserver l’ensemble des colonnes du tableau :\n\nflights %&gt;%\n  distinct(month, day, .keep_all = TRUE)\n\n# A tibble: 365 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     2       42           2359        43      518            442\n 3  2013     1     3       32           2359        33      504            442\n 4  2013     1     4       25           2359        26      505            442\n 5  2013     1     5       14           2359        15      503            445\n 6  2013     1     6       16           2359        17      451            442\n 7  2013     1     7       49           2359        50      531            444\n 8  2013     1     8      454            500        -6      625            648\n 9  2013     1     9        2           2359         3      432            444\n10  2013     1    10        3           2359         4      426            437\n# ℹ 355 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nLa fonction n_distinct, elle, renvoie le nombre de valeurs distinctes d’un vecteur. On peut notamment l’utiliser dans un summarise.\nDans l’exemple qui suit on calcule, pour les trois aéroports de départ de la table flights le nombre de valeurs distinctes de l’aéroport d’arrivée :\n\nflights %&gt;%\n  group_by(origin) %&gt;%\n  summarise(n_dest = n_distinct(dest))\n\n# A tibble: 3 × 2\n  origin n_dest\n  &lt;chr&gt;   &lt;int&gt;\n1 EWR        86\n2 JFK        70\n3 LGA        68\n\n\n\n\n\nrelocate peut être utilisé pour réordonner les colonnes d’une table. Par défaut, si on lui passe un ou plusieurs noms de colonnes, relocate les place en début de tableau.\n\nairports %&gt;% relocate(lat, lon)\n\n# A tibble: 1,458 × 8\n     lat    lon faa   name                             alt    tz dst   tzone    \n   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n 1  41.1  -80.6 04G   Lansdowne Airport               1044    -5 A     America/…\n 2  32.5  -85.7 06A   Moton Field Municipal Airport    264    -6 A     America/…\n 3  42.0  -88.1 06C   Schaumburg Regional              801    -6 A     America/…\n 4  41.4  -74.4 06N   Randall Airport                  523    -5 A     America/…\n 5  31.1  -81.4 09J   Jekyll Island Airport             11    -5 A     America/…\n 6  36.4  -82.2 0A9   Elizabethton Municipal Airport  1593    -5 A     America/…\n 7  41.5  -84.5 0G6   Williams County Airport          730    -5 A     America/…\n 8  42.9  -76.8 0G7   Finger Lakes Regional Airport    492    -5 A     America/…\n 9  39.8  -76.6 0P2   Shoestring Aviation Airfield    1000    -5 U     America/…\n10  48.1 -123.  0S9   Jefferson County Intl            108    -8 A     America/…\n# ℹ 1,448 more rows\n\n\nLes arguments supplémentaires .before et .after permettent de préciser à quel endroit déplacer la ou les colonnes indiquées.\n\nairports %&gt;% relocate(starts_with('tz'), .after = name)\n\n# A tibble: 1,458 × 8\n   faa   name                              tz tzone       lat    lon   alt dst  \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n 1 04G   Lansdowne Airport                 -5 America/…  41.1  -80.6  1044 A    \n 2 06A   Moton Field Municipal Airport     -6 America/…  32.5  -85.7   264 A    \n 3 06C   Schaumburg Regional               -6 America/…  42.0  -88.1   801 A    \n 4 06N   Randall Airport                   -5 America/…  41.4  -74.4   523 A    \n 5 09J   Jekyll Island Airport             -5 America/…  31.1  -81.4    11 A    \n 6 0A9   Elizabethton Municipal Airport    -5 America/…  36.4  -82.2  1593 A    \n 7 0G6   Williams County Airport           -5 America/…  41.5  -84.5   730 A    \n 8 0G7   Finger Lakes Regional Airport     -5 America/…  42.9  -76.8   492 A    \n 9 0P2   Shoestring Aviation Airfield      -5 America/…  39.8  -76.6  1000 U    \n10 0S9   Jefferson County Intl             -8 America/…  48.1 -123.    108 A    \n# ℹ 1,448 more rows\n\n\n\n\n\n\nLe jeu de données nycflights13 est un exemple de données réparties en plusieurs tables. Ici on en a trois : les informations sur les vols dans flights, celles sur les aéroports dans airports et celles sur les compagnies aériennes dans airlines.\ndplyr propose différentes fonctions permettant de travailler avec des données structurées de cette manière.\n\n\nLes fonctions bind_rows et bind_cols permettent d’ajouter des lignes (respectivement des colonnes) à une table à partir d’une ou plusieurs autres tables.\nL’exemple suivant (certes très artificiel) montre l’utilisation de bind_rows. On commence par créer trois tableaux t1, t2 et t3 :\n\nt1 &lt;- airports %&gt;%\n  select(faa, name, lat, lon) %&gt;%\n  slice(1:2)\nt1\n\n# A tibble: 2 × 4\n  faa   name                            lat   lon\n  &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt;\n1 04G   Lansdowne Airport              41.1 -80.6\n2 06A   Moton Field Municipal Airport  32.5 -85.7\n\n\n\nt2 &lt;- airports %&gt;%\n  select(faa, name, lat, lon) %&gt;%\n  slice(5:6)\n\nt2\n\n# A tibble: 2 × 4\n  faa   name                             lat   lon\n  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n1 09J   Jekyll Island Airport           31.1 -81.4\n2 0A9   Elizabethton Municipal Airport  36.4 -82.2\n\n\n\nt3 &lt;- airports %&gt;%\n  select(faa, name) %&gt;%\n  slice(100:101)\nt3\n\n# A tibble: 2 × 2\n  faa   name             \n  &lt;chr&gt; &lt;chr&gt;            \n1 ADW   Andrews Afb      \n2 AET   Allakaket Airport\n\n\nOn concaténe ensuite les trois tables avec bind_rows :\n\nbind_rows(t1, t2, t3)\n\n# A tibble: 6 × 4\n  faa   name                             lat   lon\n  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n1 04G   Lansdowne Airport               41.1 -80.6\n2 06A   Moton Field Municipal Airport   32.5 -85.7\n3 09J   Jekyll Island Airport           31.1 -81.4\n4 0A9   Elizabethton Municipal Airport  36.4 -82.2\n5 ADW   Andrews Afb                     NA    NA  \n6 AET   Allakaket Airport               NA    NA  \n\n\nOn remarquera que si des colonnes sont manquantes pour certaines tables, comme les colonnes lat et lon de t3, des NA sont automatiquement insérées.\nIl peut être utile, quand on concatène des lignes, de garder une trace du tableau d’origine de chacune des lignes dans le tableau final. C’est possible grâce à l’argument .id de bind_rows. On passe à cet argument le nom d’une colonne qui contiendra l’indicateur d’origine des lignes :\n\nbind_rows(t1, t2, t3, .id = \"source\")\n\n# A tibble: 6 × 5\n  source faa   name                             lat   lon\n  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n1 1      04G   Lansdowne Airport               41.1 -80.6\n2 1      06A   Moton Field Municipal Airport   32.5 -85.7\n3 2      09J   Jekyll Island Airport           31.1 -81.4\n4 2      0A9   Elizabethton Municipal Airport  36.4 -82.2\n5 3      ADW   Andrews Afb                     NA    NA  \n6 3      AET   Allakaket Airport               NA    NA  \n\n\nPar défaut la colonne .id ne contient qu’un nombre, différent pour chaque tableau. On peut lui spécifier des valeurs plus explicites en “nommant” les tables dans bind_rows de la manière suivante :\n\nbind_rows(table1 = t1, table2 = t2, table3 = t3, .id = \"source\")\n\n# A tibble: 6 × 5\n  source faa   name                             lat   lon\n  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n1 table1 04G   Lansdowne Airport               41.1 -80.6\n2 table1 06A   Moton Field Municipal Airport   32.5 -85.7\n3 table2 09J   Jekyll Island Airport           31.1 -81.4\n4 table2 0A9   Elizabethton Municipal Airport  36.4 -82.2\n5 table3 ADW   Andrews Afb                     NA    NA  \n6 table3 AET   Allakaket Airport               NA    NA  \n\n\nbind_cols permet de concaténer des colonnes et fonctionne de manière similaire :\n\nt1 &lt;- flights %&gt;% slice(1:5) %&gt;% select(dep_delay, dep_time)\nt2 &lt;- flights %&gt;% slice(1:5) %&gt;% select(origin, dest)\nt3 &lt;- flights %&gt;% slice(1:5) %&gt;% select(arr_delay, arr_time)\nbind_cols(t1, t2, t3)\n\n# A tibble: 5 × 6\n  dep_delay dep_time origin dest  arr_delay arr_time\n      &lt;dbl&gt;    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;    &lt;int&gt;\n1         2      517 EWR    IAH          11      830\n2         4      533 LGA    IAH          20      850\n3         2      542 JFK    MIA          33      923\n4        -1      544 JFK    BQN         -18     1004\n5        -6      554 LGA    ATL         -25      812\n\n\nÀ noter que bind_cols associe les lignes uniquement par position. Les lignes des différents tableaux associés doivent donc correspondre (et leur nombre doit être identique). Pour associer des tables par valeur, on doit utiliser des jointures.\n\n\n\n\n\nTrès souvent, les données relatives à une analyse sont réparties dans plusieurs tables différentes. Dans notre exemple, on peut voir que la table flights contient le code de la compagnie aérienne du vol dans la variable carrier :\n\nflights %&gt;% select(carrier)\n\n# A tibble: 336,776 × 1\n   carrier\n   &lt;chr&gt;  \n 1 UA     \n 2 UA     \n 3 AA     \n 4 B6     \n 5 DL     \n 6 UA     \n 7 B6     \n 8 EV     \n 9 B6     \n10 AA     \n# ℹ 336,766 more rows\n\n\nEt que par ailleurs la table airlines contient une information supplémentaire relative à ces compagnies, à savoir le nom complet.\n\nairlines\n\n# A tibble: 16 × 2\n   carrier name                       \n   &lt;chr&gt;   &lt;chr&gt;                      \n 1 9E      Endeavor Air Inc.          \n 2 AA      American Airlines Inc.     \n 3 AS      Alaska Airlines Inc.       \n 4 B6      JetBlue Airways            \n 5 DL      Delta Air Lines Inc.       \n 6 EV      ExpressJet Airlines Inc.   \n 7 F9      Frontier Airlines Inc.     \n 8 FL      AirTran Airways Corporation\n 9 HA      Hawaiian Airlines Inc.     \n10 MQ      Envoy Air                  \n11 OO      SkyWest Airlines Inc.      \n12 UA      United Air Lines Inc.      \n13 US      US Airways Inc.            \n14 VX      Virgin America             \n15 WN      Southwest Airlines Co.     \n16 YV      Mesa Airlines Inc.         \n\n\nIl est donc naturel de vouloir associer les deux, ici pour ajouter les noms complets des compagnies à la table flights. Pour cela on va effectuer une jointure : les lignes d’une table seront associées à une autre en se basant non pas sur leur position, mais sur les valeurs d’une ou plusieurs colonnes. Ces colonnes sont appelées des clés.\nPour faire une jointure de ce type, on va utiliser la fonction left_join :\n\nleft_join(flights, airlines)\n\nPour faciliter la lecture, on va afficher seulement certaines colonnes du résultat :\n\nleft_join(flights, airlines) %&gt;%\n  select(month, day, carrier, name)\n\nJoining with `by = join_by(carrier)`\n\n\n# A tibble: 336,776 × 4\n   month   day carrier name                    \n   &lt;int&gt; &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;                   \n 1     1     1 UA      United Air Lines Inc.   \n 2     1     1 UA      United Air Lines Inc.   \n 3     1     1 AA      American Airlines Inc.  \n 4     1     1 B6      JetBlue Airways         \n 5     1     1 DL      Delta Air Lines Inc.    \n 6     1     1 UA      United Air Lines Inc.   \n 7     1     1 B6      JetBlue Airways         \n 8     1     1 EV      ExpressJet Airlines Inc.\n 9     1     1 B6      JetBlue Airways         \n10     1     1 AA      American Airlines Inc.  \n# ℹ 336,766 more rows\n\n\nOn voit que la table résultat est bien la fusion des deux tables d’origine selon les valeurs des deux colonnes clés carrier. On est parti de la table flights, et pour chaque ligne de celle-ci on a ajouté les colonnes de airlines pour lesquelles la valeur de carrier est la même. On a donc bien une nouvelle colonne name dans notre table résultat, avec le nom complet de la compagnie aérienne.\n\n\n\n\n\n\nNote\n\n\n\nÀ noter qu’on peut tout à fait utiliser le pipe avec les fonctions de jointure :\nflights %&gt;% left_join(airlines).\n\n\nNous sommes ici dans le cas le plus simple concernant les clés de jointure : les deux clés sont uniques et portent le même nom dans les deux tables. Par défaut, si on ne lui spécifie pas explicitement les clés, dplyr fusionne en utilisant l’ensemble des colonnes communes aux deux tables. On peut d’ailleurs voir dans cet exemple qu’un message a été affiché précisant que la jointure s’est bien faite sur la variable carrier.\n\n\n\nLa table airports, contient des informations supplémentaires sur les aéroports : nom complet, altitude, position géographique, etc. Chaque aéroport est identifié par un code contenu dans la colonne faa.\nSi on regarde la table flights, on voit que le code d’identification des aéroports apparaît à deux endroits différents : pour l’aéroport de départ dans la colonne origin, et pour celui d’arrivée dans la colonne dest. On a donc deux clés de jointure possibles, et qui portent un nom différent de la clé de airports.\nOn va commencer par fusionner les données concernant l’aéroport de départ. Pour simplifier l’affichage des résultats, on va se contenter d’un sous-ensemble des deux tables :\n\nflights_ex &lt;- flights %&gt;% select(month, day, origin, dest)\nairports_ex &lt;- airports %&gt;% select(faa, alt, name)\n\nSi on se contente d’un left_join comme à l’étape précédente, on obtient un message d’erreur car aucune colonne commune ne peut être identifiée comme clé de jointure :\n\nflights_ex %&gt;% left_join(airports_ex)\n\nError in `left_join()`:\n! `by` must be supplied when `x` and `y` have no common variables.\nℹ Use `cross_join()` to perform a cross-join.\n\n\nOn doit donc spécifier explicitement les clés avec l’argument by de left_join. Ici la clé est nommée origin dans la première table, et faa dans la seconde. La syntaxe est donc la suivante :\n\nflights_ex %&gt;% \n  left_join(airports_ex, by = c(\"origin\" = \"faa\"))\n\n# A tibble: 336,776 × 6\n   month   day origin dest    alt name               \n   &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;              \n 1     1     1 EWR    IAH      18 Newark Liberty Intl\n 2     1     1 LGA    IAH      22 La Guardia         \n 3     1     1 JFK    MIA      13 John F Kennedy Intl\n 4     1     1 JFK    BQN      13 John F Kennedy Intl\n 5     1     1 LGA    ATL      22 La Guardia         \n 6     1     1 EWR    ORD      18 Newark Liberty Intl\n 7     1     1 EWR    FLL      18 Newark Liberty Intl\n 8     1     1 LGA    IAD      22 La Guardia         \n 9     1     1 JFK    MCO      13 John F Kennedy Intl\n10     1     1 LGA    ORD      22 La Guardia         \n# ℹ 336,766 more rows\n\n\nOn constate que les deux nouvelles colonnes name et alt contiennent bien les données correspondant à l’aéroport de départ.\nOn va stocker le résultat de cette jointure dans la table flights_ex :\n\nflights_ex &lt;- flights_ex %&gt;%\n  left_join(airports_ex, by = c(\"origin\" = \"faa\"))\n\nSupposons qu’on souhaite maintenant fusionner à nouveau les informations de la table airports, mais cette fois pour les aéroports d’arrivée de notre nouvelle table flights_ex. Les deux clés sont donc désormais dest dans la première table, et faa dans la deuxième. La syntaxe est donc la suivante :\n\nflights_ex %&gt;%\n  left_join(airports_ex, by = c(\"dest\" = \"faa\"))\n\n# A tibble: 336,776 × 8\n   month   day origin dest  alt.x name.x              alt.y name.y              \n   &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;               \n 1     1     1 EWR    IAH      18 Newark Liberty Intl    97 George Bush Interco…\n 2     1     1 LGA    IAH      22 La Guardia             97 George Bush Interco…\n 3     1     1 JFK    MIA      13 John F Kennedy Intl     8 Miami Intl          \n 4     1     1 JFK    BQN      13 John F Kennedy Intl    NA &lt;NA&gt;                \n 5     1     1 LGA    ATL      22 La Guardia           1026 Hartsfield Jackson …\n 6     1     1 EWR    ORD      18 Newark Liberty Intl   668 Chicago Ohare Intl  \n 7     1     1 EWR    FLL      18 Newark Liberty Intl     9 Fort Lauderdale Hol…\n 8     1     1 LGA    IAD      22 La Guardia            313 Washington Dulles I…\n 9     1     1 JFK    MCO      13 John F Kennedy Intl    96 Orlando Intl        \n10     1     1 LGA    ORD      22 La Guardia            668 Chicago Ohare Intl  \n# ℹ 336,766 more rows\n\n\nCela fonctionne, les informations de l’aéroport d’arrivée ont bien été ajoutées, mais on constate que les colonnes ont été renommées. En effet, ici les deux tables fusionnées contenaient toutes les deux des colonnes name et alt. Comme on ne peut pas avoir deux colonnes avec le même nom dans un tableau, dplyr a renommé les colonnes de la première table en name.x et alt.x, et celles de la deuxième en name.y et alt.y.\nC’est pratique, mais pas forcément très parlant. On pourrait renommer manuellement les colonnes avec rename avant de faire la jointure pour avoir des intitulés plus explicites, mais on peut aussi utiliser l’argument suffix de left_join, qui permet d’indiquer les suffixes à ajouter aux colonnes.\n\nflights_ex %&gt;%\n  left_join(\n    airports_ex,\n    by = c(\"dest\" = \"faa\"),\n    suffix = c(\"_depart\", \"_arrivee\")\n  )\n\n# A tibble: 336,776 × 8\n   month   day origin dest  alt_depart name_depart      alt_arrivee name_arrivee\n   &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;                  &lt;dbl&gt; &lt;chr&gt;       \n 1     1     1 EWR    IAH           18 Newark Liberty …          97 George Bush…\n 2     1     1 LGA    IAH           22 La Guardia                97 George Bush…\n 3     1     1 JFK    MIA           13 John F Kennedy …           8 Miami Intl  \n 4     1     1 JFK    BQN           13 John F Kennedy …          NA &lt;NA&gt;        \n 5     1     1 LGA    ATL           22 La Guardia              1026 Hartsfield …\n 6     1     1 EWR    ORD           18 Newark Liberty …         668 Chicago Oha…\n 7     1     1 EWR    FLL           18 Newark Liberty …           9 Fort Lauder…\n 8     1     1 LGA    IAD           22 La Guardia               313 Washington …\n 9     1     1 JFK    MCO           13 John F Kennedy …          96 Orlando Intl\n10     1     1 LGA    ORD           22 La Guardia               668 Chicago Oha…\n# ℹ 336,766 more rows\n\n\nOn obtient ainsi directement des noms de colonnes nettement plus clairs.\n\n\n\n\nJusqu’à présent nous avons utilisé la fonction left_join, mais il existe plusieurs types de jointures.\nPartons de deux tables d’exemple, personnes et voitures :\n\npersonnes &lt;- tibble(\n    nom = c(\"Sylvie\", \"Sylvie\", \"Monique\", \"Gunter\", \"Rayan\", \"Rayan\"),\n    voiture = c(\"Twingo\", \"Ferrari\", \"Scenic\", \"Lada\", \"Twingo\", \"Clio\")\n)\n\n\n\n\n\n\nnom\nvoiture\n\n\n\n\nSylvie\nTwingo\n\n\nSylvie\nFerrari\n\n\nMonique\nScenic\n\n\nGunter\nLada\n\n\nRayan\nTwingo\n\n\nRayan\nClio\n\n\n\n\n\n\nvoitures &lt;- tibble(\n    voiture = c(\"Twingo\", \"Ferrari\", \"Clio\", \"Lada\", \"208\"),\n    vitesse = c(\"140\", \"280\", \"160\", \"85\", \"160\")\n)\n\n\n\n\n\n\nvoiture\nvitesse\n\n\n\n\nTwingo\n140\n\n\nFerrari\n280\n\n\nClio\n160\n\n\nLada\n85\n\n\n208\n160\n\n\n\n\n\n\n\nSi on fait un left_join de voitures sur personnes :\n\npersonnes %&gt;% left_join(voitures)\n\n\n\nJoining with `by = join_by(voiture)`\n\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nMonique\nScenic\nNA\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\n\n\n\nOn voit que chaque ligne de personnes est bien présente, et qu’on lui a ajouté une ligne de voitures correspondante si elle existe. Dans le cas du Scenic, il n’y a avait pas de ligne dans voitures, donc vitesse a été mise à NA. Dans le cas de 208, présente dans voitures mais pas dans personnes, la ligne n’apparaît pas.\nSi on fait un left_join cette fois de personnes sur voitures, c’est l’inverse :\n\nvoitures %&gt;% left_join(personnes)\n\n\n\nJoining with `by = join_by(voiture)`\n\n\n\n\n\nvoiture\nvitesse\nnom\n\n\n\n\nTwingo\n140\nSylvie\n\n\nTwingo\n140\nRayan\n\n\nFerrari\n280\nSylvie\n\n\nClio\n160\nRayan\n\n\nLada\n85\nGunter\n\n\n208\n160\nNA\n\n\n\n\n\nLa ligne 208 est là, mais nom est à NA. Par contre Monique est absente. Et on remarquera que la ligne Twingo, présente deux fois dans personnes, a été dupliquée pour être associée aux deux lignes de données de Sylvie et Rayan.\nEn résumé, quand on fait un left_join(x, y), toutes les lignes de x sont présentes, et dupliquées si nécessaire quand elles apparaissent plusieurs fois dans y. Les lignes de y non présentes dans x disparaissent. Les lignes de x non présentes dans y se voient attribuer des NA pour les nouvelles colonnes.\nIntuitivement, on pourrait considérer que left_join(x, y) signifie “ramener l’information de la table y sur la table x”.\nEn général, left_join sera le type de jointures le plus fréquemment utilisé.\n\n\n\nLa jointure right_join est l’exacte symétrique de left_join, c’est-à dire que right_join(x, y) est équivalent à left_join(y, x) :\n\npersonnes %&gt;% right_join(voitures)\n\n\n\nJoining with `by = join_by(voiture)`\n\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\nNA\n208\n160\n\n\n\n\n\n\n\n\nDans le cas de inner_join(x, y), seules les lignes présentes à la fois dans x et y sont conservées (et si nécessaire dupliquées) dans la table résultat :\n\npersonnes %&gt;% inner_join(voitures)\n\n\n\nJoining with `by = join_by(voiture)`\n\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\n\n\n\nIci la ligne 208 est absente, ainsi que la ligne Monique, qui dans le cas d’un left_join avait été conservée et s’était vue attribuer une vitesse à NA.\n\n\n\nDans le cas de full_join(x, y), toutes les lignes de x et toutes les lignes de y sont conservées (avec des NA ajoutés si nécessaire) même si elles sont absentes de l’autre table :\n\npersonnes %&gt;% full_join(voitures)\n\n\n\nJoining with `by = join_by(voiture)`\n\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nMonique\nScenic\nNA\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\nNA\n208\n160\n\n\n\n\n\n\n\n\n\n\nLe livre R for data science, librement accessible en ligne, contient plusieurs chapitres très complets sur la manipulation des données, notamment :\n\nData transformation pour les manipulations\nRelational data pour les tables multiples\n\nLe site de l’extension comprend une liste des fonctions et les pages d’aide associées, mais aussi une introduction au package et plusieurs articles dont un spécifiquement sur les jointures.\nEnfin, une “antisèche” très synthétique est également accessible depuis RStudio, en allant dans le menu Help puis Cheatsheets et Data Transformation with dplyr.\n\n\n\nOn commence par charger les extensions et les données nécessaires.\n\nlibrary(tidyverse)\nlibrary(nycflights13)\ndata(flights)\ndata(airports)\ndata(airlines)\n\n\n\nExercice 1.1\nSélectionner la dixième ligne du tableau des aéroports (airports).\nSélectionner les 5 premières lignes de la table airlines.\nSélectionner l’aéroport avec l’altitude la plus basse.\nExercice 1.2\nSélectionnez les vols du mois de juillet (variable month).\nSélectionnez les vols avec un retard à l’arrivée (variable arr_delay) compris entre 5 et 15 minutes.\nSélectionnez les vols des compagnies Delta, United et American (codes DL, UA et AA de la variable carrier).\nExercice 1.3\nTriez la table flights par retard au départ décroissant.\nExercice 1.4\nSélectionnez les colonnes name, lat et lon de la table airports\nSélectionnez toutes les colonnes de la table airports sauf les colonnes tz et tzone\nSélectionnez toutes les colonnes de la table flights dont les noms se terminent par “delay”.\nDans la table airports, renommez la colonne alt en altitude et la colonne tzone en fuseau_horaire.\nExercice 1.5\nDans la table airports, la colonne alt contient l’altitude de l’aéroport en pieds. Créer une nouvelle variable alt_m contenant l’altitude en mètres (on convertit des pieds en mètres en les divisant par 3.2808). Sélectionner dans la table obtenue uniquement les deux colonnes alt et alt_m.\n\n\n\nExercice 2.1\nRéécrire le code de l’exercice précédent en utilisant le pipe %&gt;%.\nExercice 2.2\nEn utilisant le pipe, sélectionnez les vols à destination de San Francico (code SFO de la variable dest) et triez-les selon le retard au départ décroissant (variable dep_delay).\nExercice 2.3\nSélectionnez les vols des mois de septembre et octobre, conservez les colonnes dest et dep_delay, créez une nouvelle variable retard_h contenant le retard au départ en heures, et conservez uniquement les 5 lignes avec les plus grandes valeurs de retard_h.\n\n\n\nExercice 3.1\nAffichez le nombre de vols par mois.\nTriez la table résultat selon le nombre de vols croissant.\nExercice 3.2\nCalculer la distance moyenne des vols selon l’aéroport de départ (variable origin).\nExercice 3.3\nCalculer le nombre de vols à destination de Los Angeles (code LAX) pour chaque mois de l’année.\nExercice 3.4\nCalculer le nombre de vols selon le mois et la destination.\nNe conserver, pour chaque mois, que la destination avec le nombre maximal de vols.\nExercice 3.5\nCalculer le nombre de vols selon le mois. Ajouter une colonne comportant le pourcentage de vols annuels réalisés par mois.\nExercice 3.6\nCalculer, pour chaque aéroport de départ et de destination, la durée moyenne des vols (variable air_time). Pour chaque aéroport de départ, ne conserver que la destination avec la durée moyenne la plus longue.\n\n\n\nExercice 4.1\nFaire la jointure de la table airlines sur la table flights à l’aide de left_join.\nExercice 4.2\nÀ partir de la table résultat de l’exercice précédent, calculer le retard moyen au départ pour chaque compagnie, et trier selon ce retard décroissant.\nExercice 4.3\nFaire la jointure de la table airports sur la table flights en utilisant comme clé le code de l’aéroport de destination.\nÀ partir de cette table, afficher pour chaque mois le nom de l’aéroport de destination ayant eu le plus petit nombre de vol.\nExercice 4.4\nCréer une table indiquant, pour chaque vol, uniquement le nom de l’aéroport de départ et celui de l’aéroport d’arrivée."
  },
  {
    "objectID": "SFC1018_Manipulation_R.html#préparation",
    "href": "SFC1018_Manipulation_R.html#préparation",
    "title": "Manipulation de données",
    "section": "",
    "text": "dplyr fait partie du coeur du tidyverse, elle est donc chargée automatiquement avec :\n\nlibrary(tidyverse)\n\nOn peut également la charger individuellement.\n\nlibrary(dplyr)\n\nDans ce qui suit on va utiliser le jeu de données nycflights13, contenu dans l’extension du même nom (qu’il faut donc avoir installé). Celui-ci correspond aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. Il a la particularité d’être réparti en trois tables :\n\nflights contient des informations sur les vols : date, départ, destination, horaires, retard…\nairports contient des informations sur les aéroports\nairlines contient des données sur les compagnies aériennes\n\nOn va charger les trois tables du jeu de données :\n\nlibrary(nycflights13)\n## Chargement des trois tables\ndata(flights)\ndata(airports)\ndata(airlines)\n\nTrois objets correspondant aux trois tables ont dû apparaître dans votre environnement."
  },
  {
    "objectID": "SFC1018_Manipulation_R.html#les-verbes-de-dplyr",
    "href": "SFC1018_Manipulation_R.html#les-verbes-de-dplyr",
    "title": "Manipulation de données",
    "section": "",
    "text": "La manipulation de données avec dplyr se fait en utilisant un nombre réduit de verbes, qui correspondent chacun à une action différente appliquée à un tableau de données.\n\n\nLe verbe slice sélectionne des lignes du tableau selon leur position. On lui passe un chiffre ou un vecteur de chiffres.\nSi on souhaite sélectionner la 345e ligne du tableau airports :\n\nslice(airports, 345)\n\n# A tibble: 1 × 8\n  faa   name                lat   lon   alt    tz dst   tzone            \n  &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            \n1 CYF   Chefornak Airport  60.1 -164.    40    -9 A     America/Anchorage\n\n\nSi on veut sélectionner les 5 premières lignes :\n\nslice(airports, 1:5)\n\n# A tibble: 5 × 8\n  faa   name                            lat   lon   alt    tz dst   tzone       \n  &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       \n1 04G   Lansdowne Airport              41.1 -80.6  1044    -5 A     America/New…\n2 06A   Moton Field Municipal Airport  32.5 -85.7   264    -6 A     America/Chi…\n3 06C   Schaumburg Regional            42.0 -88.1   801    -6 A     America/Chi…\n4 06N   Randall Airport                41.4 -74.4   523    -5 A     America/New…\n5 09J   Jekyll Island Airport          31.1 -81.4    11    -5 A     America/New…\n\n\nslice propose plusieurs variantes utiles, dont slice_head et slice_tail, qui permettent de sélectionner les premières ou les dernières lignes du tableau (on peut spécifier le nombre de lignes souhaitées avec n, ou la proportion avec prop).\n\nslice_tail(airports, n = 3)\n\n# A tibble: 3 × 8\n  faa   name                        lat   lon   alt    tz dst   tzone           \n  &lt;chr&gt; &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n1 ZWI   Wilmington Amtrak Station  39.7 -75.6     0    -5 A     America/New_York\n2 ZWU   Washington Union Station   38.9 -77.0    76    -5 A     America/New_York\n3 ZYP   Penn Station               40.8 -74.0    35    -5 A     America/New_York\n\n\n\nslice_head(airlines, prop = 0.2)\n\n# A tibble: 3 × 2\n  carrier name                  \n  &lt;chr&gt;   &lt;chr&gt;                 \n1 9E      Endeavor Air Inc.     \n2 AA      American Airlines Inc.\n3 AS      Alaska Airlines Inc.  \n\n\nAutres variantes utiles, slice_min et slice_max permettent de sélectionner les lignes avec les valeurs les plus grandes ou les plus petite d’une variable donnée. Ainsi, la commande suivante sélectionne le vol ayant le retard au départ le plus faible.\n\nslice_min(flights, dep_delay)\n\n# A tibble: 1 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013    12     7     2040           2123       -43       40           2352\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut aussi spécifier le nombre de lignes souhaitées, par exemple la commande suivante retourne les 5 aéroports avec l’altitude la plus élevée (en cas de valeurs ex-aequo, il se peut que le nombre de lignes retournées soit plus élevé que celui demandé).\n\nslice_max(airports, alt, n = 5)\n\n# A tibble: 5 × 8\n  faa   name                              lat   lon   alt    tz dst   tzone     \n  &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n1 TEX   Telluride                        38.0 -108.  9078    -7 A     America/D…\n2 TVL   Lake Tahoe Airport               38.9 -120.  8544    -8 A     America/L…\n3 ASE   Aspen Pitkin County Sardy Field  39.2 -107.  7820    -7 A     America/D…\n4 GUC   Gunnison - Crested Butte         38.5 -107.  7678    -7 A     America/D…\n5 BCE   Bryce Canyon                     37.7 -112.  7590    -7 A     America/D…\n\n\n\n\n\nfilter sélectionne des lignes d’une table selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie TRUE (vrai) sont conservées. Pour plus d’informations sur les tests et leur syntaxe, voir ?@sec-tests.\nPar exemple, si on veut sélectionner les vols du mois de janvier, on peut filtrer sur la variable month de la manière suivante :\n\nfilter(flights, month == 1)\n\n# A tibble: 27,004 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 26,994 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut uniquement les vols avec un retard au départ (variable dep_delay) compris entre 10 et 15 minutes :\n\nfilter(flights, dep_delay &gt;= 10 & dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on passe plusieurs arguments à filter, celui-ci rajoute automatiquement une condition et entre les conditions. La commande précédente peut donc être écrite de la manière suivante, avec le même résultat :\n\nfilter(flights, dep_delay &gt;= 10, dep_delay &lt;= 15)\n\nOn peut également placer des fonctions dans les tests, qui nous permettent par exemple de sélectionner les vols ayant une distance supérieure à la distance médiane :\n\nfilter(flights, distance &gt; median(distance))\n\n# A tibble: 167,133 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      555            600        -5      913            854\n 6  2013     1     1      557            600        -3      838            846\n 7  2013     1     1      558            600        -2      849            851\n 8  2013     1     1      558            600        -2      853            856\n 9  2013     1     1      558            600        -2      924            917\n10  2013     1     1      558            600        -2      923            937\n# ℹ 167,123 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nselect permet de sélectionner des colonnes d’un tableau de données. Ainsi, si on veut extraire les colonnes lat et lon du tableau airports :\n\nselect(airports, lat, lon)\n\n# A tibble: 1,458 × 2\n     lat    lon\n   &lt;dbl&gt;  &lt;dbl&gt;\n 1  41.1  -80.6\n 2  32.5  -85.7\n 3  42.0  -88.1\n 4  41.4  -74.4\n 5  31.1  -81.4\n 6  36.4  -82.2\n 7  41.5  -84.5\n 8  42.9  -76.8\n 9  39.8  -76.6\n10  48.1 -123. \n# ℹ 1,448 more rows\n\n\nSi on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée :\n\nselect(airports, -lat, -lon)\n\n# A tibble: 1,458 × 6\n   faa   name                             alt    tz dst   tzone              \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              \n 1 04G   Lansdowne Airport               1044    -5 A     America/New_York   \n 2 06A   Moton Field Municipal Airport    264    -6 A     America/Chicago    \n 3 06C   Schaumburg Regional              801    -6 A     America/Chicago    \n 4 06N   Randall Airport                  523    -5 A     America/New_York   \n 5 09J   Jekyll Island Airport             11    -5 A     America/New_York   \n 6 0A9   Elizabethton Municipal Airport  1593    -5 A     America/New_York   \n 7 0G6   Williams County Airport          730    -5 A     America/New_York   \n 8 0G7   Finger Lakes Regional Airport    492    -5 A     America/New_York   \n 9 0P2   Shoestring Aviation Airfield    1000    -5 U     America/New_York   \n10 0S9   Jefferson County Intl            108    -8 A     America/Los_Angeles\n# ℹ 1,448 more rows\n\n\nselect comprend toute une série de fonctions facilitant la sélection de colonnes multiples. Par exemple, starts_with, ends_width, contains ou matches permettent d’exprimer des conditions sur les noms de variables.\n\nselect(flights, starts_with(\"dep_\"))\n\n# A tibble: 336,776 × 2\n   dep_time dep_delay\n      &lt;int&gt;     &lt;dbl&gt;\n 1      517         2\n 2      533         4\n 3      542         2\n 4      544        -1\n 5      554        -6\n 6      554        -4\n 7      555        -5\n 8      557        -3\n 9      557        -3\n10      558        -2\n# ℹ 336,766 more rows\n\n\nLa syntaxe colonne1:colonne2 permet de sélectionner toutes les colonnes situées entre colonne1 et colonne2 incluses1.\n\nselect(flights, year:day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\nselect propose de nombreuses autres possibilités de sélection qui sont décrites dans la documentation de l’extension tidyselect.\nUne variante de select est rename2, qui permet de renommer des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom. Ainsi, si on veut renommer les colonnes lon et lat de airports en longitude et latitude :\n\nrename(airports, longitude = lon, latitude = lat)\n\n# A tibble: 1,458 × 8\n   faa   name                         latitude longitude   alt    tz dst   tzone\n   &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n 1 04G   Lansdowne Airport                41.1     -80.6  1044    -5 A     Amer…\n 2 06A   Moton Field Municipal Airpo…     32.5     -85.7   264    -6 A     Amer…\n 3 06C   Schaumburg Regional              42.0     -88.1   801    -6 A     Amer…\n 4 06N   Randall Airport                  41.4     -74.4   523    -5 A     Amer…\n 5 09J   Jekyll Island Airport            31.1     -81.4    11    -5 A     Amer…\n 6 0A9   Elizabethton Municipal Airp…     36.4     -82.2  1593    -5 A     Amer…\n 7 0G6   Williams County Airport          41.5     -84.5   730    -5 A     Amer…\n 8 0G7   Finger Lakes Regional Airpo…     42.9     -76.8   492    -5 A     Amer…\n 9 0P2   Shoestring Aviation Airfield     39.8     -76.6  1000    -5 U     Amer…\n10 0S9   Jefferson County Intl            48.1    -123.    108    -8 A     Amer…\n# ℹ 1,448 more rows\n\n\nSi les noms de colonnes comportent des espaces ou des caractères spéciaux, on peut les entourer de guillemets (\") ou de quotes inverses (`) :\n\ntmp &lt;- rename(\n    flights,\n    \"retard départ\" = dep_delay,\n    \"retard arrivée\" = arr_delay\n)\nselect(tmp, `retard départ`, `retard arrivée`)\n\n# A tibble: 336,776 × 2\n   `retard départ` `retard arrivée`\n             &lt;dbl&gt;            &lt;dbl&gt;\n 1               2               11\n 2               4               20\n 3               2               33\n 4              -1              -18\n 5              -6              -25\n 6              -4               12\n 7              -5               19\n 8              -3              -14\n 9              -3               -8\n10              -2                8\n# ℹ 336,766 more rows\n\n\n\n\n\narrange réordonne les lignes d’un tableau selon une ou plusieurs colonnes.\nAinsi, si on veut trier le tableau flights selon le retard au départ croissant :\n\narrange(flights, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013    12     7     2040           2123       -43       40           2352\n 2  2013     2     3     2022           2055       -33     2240           2338\n 3  2013    11    10     1408           1440       -32     1549           1559\n 4  2013     1    11     1900           1930       -30     2233           2243\n 5  2013     1    29     1703           1730       -27     1947           1957\n 6  2013     8     9      729            755       -26     1002            955\n 7  2013    10    23     1907           1932       -25     2143           2143\n 8  2013     3    30     2030           2055       -25     2213           2250\n 9  2013     3     2     1431           1455       -24     1601           1631\n10  2013     5     5      934            958       -24     1225           1309\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOn peut trier selon plusieurs colonnes. Par exemple selon le mois, puis selon le retard au départ :\n\narrange(flights, month, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1    11     1900           1930       -30     2233           2243\n 2  2013     1    29     1703           1730       -27     1947           1957\n 3  2013     1    12     1354           1416       -22     1606           1650\n 4  2013     1    21     2137           2159       -22     2232           2316\n 5  2013     1    20      704            725       -21     1025           1035\n 6  2013     1    12     2050           2110       -20     2310           2355\n 7  2013     1    12     2134           2154       -20        4             50\n 8  2013     1    14     2050           2110       -20     2329           2355\n 9  2013     1     4     2140           2159       -19     2241           2316\n10  2013     1    11     1947           2005       -18     2209           2230\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSi on veut trier selon une colonne par ordre décroissant, on lui applique la fonction desc() :\n\narrange(flights, desc(dep_delay))\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nCombiné avec slice, arrange permet par exemple de sélectionner les trois vols ayant eu le plus de retard :\n\ntmp &lt;- arrange(flights, desc(dep_delay))\nslice(tmp, 1:3)\n\n# A tibble: 3 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013     1     9      641            900      1301     1242           1530\n2  2013     6    15     1432           1935      1137     1607           2120\n3  2013     1    10     1121           1635      1126     1239           1810\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\nmutate permet de créer de nouvelles colonnes dans le tableau de données, en général à partir de variables existantes.\nPar exemple, la table flights contient la durée du vol en minutes.. Si on veut créer une nouvelle variable duree_h avec cette durée en heures, on peut faire :\n\nflights &lt;- mutate(flights, duree_h = air_time / 60)\n\nselect(flights, air_time, duree_h)\n\n# A tibble: 336,776 × 2\n   air_time duree_h\n      &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78 \n 2      227   3.78 \n 3      160   2.67 \n 4      183   3.05 \n 5      116   1.93 \n 6      150   2.5  \n 7      158   2.63 \n 8       53   0.883\n 9      140   2.33 \n10      138   2.3  \n# ℹ 336,766 more rows\n\n\nOn peut créer plusieurs nouvelles colonnes en une seule commande, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. L’exemple suivant convertit d’abord la durée en heures dans une variable duree_h et la distance en kilomètres dans une variable distance_km, puis utilise ces nouvelles colonnes pour calculer la vitesse en km/h.\n\nflights &lt;- mutate(\n    flights,\n    duree_h = air_time / 60,\n    distance_km = distance / 0.62137,\n    vitesse = distance_km / duree_h\n)\n\nselect(flights, air_time, duree_h, distance, distance_km, vitesse)\n\n# A tibble: 336,776 × 5\n   air_time duree_h distance distance_km vitesse\n      &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n 1      227   3.78      1400       2253.    596.\n 2      227   3.78      1416       2279.    602.\n 3      160   2.67      1089       1753.    657.\n 4      183   3.05      1576       2536.    832.\n 5      116   1.93       762       1226.    634.\n 6      150   2.5        719       1157.    463.\n 7      158   2.63      1065       1714.    651.\n 8       53   0.883      229        369.    417.\n 9      140   2.33       944       1519.    651.\n10      138   2.3        733       1180.    513.\n# ℹ 336,766 more rows\n\n\nÀ noter que mutate est évidemment parfaitement compatible avec les fonctions vues ?@sec-vectorfactor sur les recodages : fct_recode, ifelse, case_when…\nL’avantage d’utiliser mutate est double. D’abord il permet d’éviter d’avoir à saisir le nom du tableau de données dans les conditions d’un ifelse ou d’un case_when :\n\nflights &lt;- mutate(\n    flights,\n    type_retard = case_when(\n        dep_delay &gt; 0 & arr_delay &gt; 0 ~ \"Retard départ et arrivée\",\n        dep_delay &gt; 0 & arr_delay &lt;= 0 ~ \"Retard départ\",\n        dep_delay &lt;= 0 & arr_delay &gt; 0 ~ \"Retard arrivée\",\n        TRUE ~ \"Aucun retard\"\n    )\n)\n\nEnsuite, il permet aussi d’intégrer ces recodages dans un pipeline de traitement de données, concept présenté dans la section suivante."
  },
  {
    "objectID": "SFC1018_Manipulation_R.html#sec-pipe",
    "href": "SFC1018_Manipulation_R.html#sec-pipe",
    "title": "Manipulation de données",
    "section": "",
    "text": "Quand on manipule un tableau de données, il est très fréquent d’enchaîner plusieurs opérations. On va par exemple extraire une sous-population avec filter, sélectionner des colonnes avec select puis trier selon une variable avec arrange, etc.\nQuand on veut enchaîner des opérations, on peut le faire de différentes manières. La première est d’effectuer toutes les opérations en une fois en les “emboîtant” :\n\narrange(select(filter(flights, dest == \"LAX\"), dep_delay, arr_delay), dep_delay)\n\nCette notation a plusieurs inconvénients :\n\nelle est peu lisible\nles opérations apparaissent dans l’ordre inverse de leur réalisation. Ici on effectue d’abord le filter, puis le select, puis le arrange, alors qu’à la lecture du code c’est le arrange qui apparaît en premier.\nIl est difficile de voir quel paramètre se rapporte à quelle fonction\n\nUne autre manière de faire est d’effectuer les opérations les unes après les autres, en stockant les résultats intermédiaires dans un objet temporaire :\n\ntmp &lt;- filter(flights, dest == \"LAX\")\ntmp &lt;- select(tmp, dep_delay, arr_delay)\narrange(tmp, dep_delay)\n\nC’est nettement plus lisible, l’ordre des opérations est le bon, et les paramètres sont bien rattachés à leur fonction. Par contre, ça reste un peu “verbeux”, et on crée un objet temporaire tmp dont on n’a pas réellement besoin.\nPour simplifier et améliorer encore la lisibilité du code, on va utiliser un nouvel opérateur, baptisé pipe3. Le pipe se note %&gt;%, et son fonctionnement est le suivant : si j’exécute expr %&gt;% f, alors le résultat de l’expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr).\nAinsi les deux expressions suivantes sont rigoureusement équivalentes :\n\nfilter(flights, dest == \"LAX\")\n\n\nflights %&gt;% filter(dest == \"LAX\")\n\nCe qui est particulièrement intéressant, c’est qu’on va pouvoir enchaîner les pipes. Plutôt que d’écrire :\n\nselect(filter(flights, dest == \"LAX\"), dep_delay, arr_delay)\n\nOn va pouvoir faire :\n\nflights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay)\n\nÀ chaque fois, le résultat de ce qui se trouve à gauche du pipe est passé comme premier argument à ce qui se trouve à droite : on part de l’objet flights, qu’on passe comme premier argument à la fonction filter, puis on passe le résultat de ce filter comme premier argument du select.\nLe résultat final est le même avec les deux syntaxes, mais avec le pipe l’ordre des opérations correspond à l’ordre naturel de leur exécution, et on n’a pas eu besoin de créer d’objet intermédiaire.\nSi la liste des fonctions enchaînées est longue, on peut les répartir sur plusieurs lignes à condition que l’opérateur %&gt;% soit en fin de ligne :\n\nflights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\n\n\n\n\n\n\nNote\n\n\n\nOn appelle une suite d’instructions de ce type un pipeline.\n\n\nÉvidemment, il est naturel de vouloir récupérer le résultat final d’un pipeline pour le stocker dans un objet. On peut stocker le résultat du pipeline ci-dessus dans un nouveau tableau delay_la de la manière suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\nDans ce cas, delay_la contiendra le tableau final, obtenu après application des trois instructions filter, select et arrange.\nCette notation n’est pas forcément très intuitive au départ : il faut bien comprendre que c’est le résultat final, une fois application de toutes les opérations du pipeline, qui est renvoyé et stocké dans l’objet en début de ligne.\nUne manière de le comprendre peut être de voir que la notation suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay)\n\nest équivalente à :\n\ndelay_la &lt;- (flights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay))\n\n\n\n\n\n\n\nNote\n\n\n\nL’utilisation du pipe n’est pas obligatoire, mais elle rend les scripts plus lisibles et plus rapides à saisir. On l’utilisera donc dans ce qui suit.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nDepuis la version 4.1, R propose un pipe “natif”, qui fonctionne partout, même si on n’utilise pas les extensions du tidyverse. Celui-ci est noté |&gt;.\nIl s’utilise de la même manière que %&gt;% :\nflights |&gt; filter(dest == \"LAX\")\nCe pipe natif est à la fois un peu plus rapide et un peu moins souple. Par exemple, il est possible avec %&gt;% d’appeler une fonction sans mettre de parenthèses :\ndf %&gt;% View\nCe n’est pas possible d’omettre les parenthèses avec |&gt;, on doit obligatoirement faire :\ndf |&gt; View()\nDans la suite de ce document on privilégiera (pour l’instant) le pipe du tidyverse %&gt;%, pour des raisons de compatibilité avec des versions de R moins récentes."
  },
  {
    "objectID": "SFC1018_Manipulation_R.html#opérations-groupées",
    "href": "SFC1018_Manipulation_R.html#opérations-groupées",
    "title": "Manipulation de données",
    "section": "",
    "text": "Un élément très important de dplyr est la fonction group_by. Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois :\n\nflights %&gt;% group_by(month)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPar défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups dans l’affichage du résultat. Mais à partir du moment où des groupes ont été définis, les verbes comme slice, mutate ou summarise vont en tenir compte lors de leurs opérations.\nPar exemple, si on applique slice à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe. Ainsi la commande suivante affiche le premier vol de chaque mois, selon leur ordre d’apparition dans le tableau :\n\nflights %&gt;% group_by(month) %&gt;% slice(1)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     2     1      456            500        -4      652            648\n 3  2013     3     1        4           2159       125      318             56\n 4  2013     4     1      454            500        -6      636            640\n 5  2013     5     1        9           1655       434      308           2020\n 6  2013     6     1        2           2359         3      341            350\n 7  2013     7     1        1           2029       212      236           2359\n 8  2013     8     1       12           2130       162      257             14\n 9  2013     9     1        9           2359        10      343            340\n10  2013    10     1      447            500       -13      614            648\n11  2013    11     1        5           2359         6      352            345\n12  2013    12     1       13           2359        14      446            445\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nPlus utile, en utilisant une variante comme slice_min ou slice_max, on peut sélectionner les lignes ayant les valeurs les plus grandes ou les plus petites pour chaque groupe. Par exemple la commande suivant sélectionne, pour chaque mois de l’année, le vol ayant eu le retard le plus important.\n\nflights %&gt;% group_by(month) %&gt;% slice_max(dep_delay)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     2    10     2243            830       853      100           1106\n 3  2013     3    17     2321            810       911      135           1020\n 4  2013     4    10     1100           1900       960     1342           2211\n 5  2013     5     3     1133           2055       878     1250           2215\n 6  2013     6    15     1432           1935      1137     1607           2120\n 7  2013     7    22      845           1600      1005     1044           1815\n 8  2013     8     8     2334           1454       520      120           1710\n 9  2013     9    20     1139           1845      1014     1457           2210\n10  2013    10    14     2042            900       702     2255           1127\n11  2013    11     3      603           1645       798      829           1913\n12  2013    12     5      756           1700       896     1058           2020\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nIdem pour mutate : les opérations appliquées lors du calcul des valeurs des nouvelles colonnes sont appliquées groupe de lignes par groupe de lignes. Dans l’exemple suivant, on ajoute une nouvelle colonne qui contient le retard moyen pour chaque compagnie aérienne. Cette valeur est donc différente d’une compagnie à une autre, mais identique pour tous les vols d’une même compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(mean_delay_carrier = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  select(dep_delay, mean_delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 3\n# Groups:   carrier [16]\n   carrier dep_delay mean_delay_carrier\n   &lt;chr&gt;       &lt;dbl&gt;              &lt;dbl&gt;\n 1 UA              2              12.1 \n 2 UA              4              12.1 \n 3 AA              2               8.59\n 4 B6             -1              13.0 \n 5 DL             -6               9.26\n 6 UA             -4              12.1 \n 7 B6             -5              13.0 \n 8 EV             -3              20.0 \n 9 B6             -3              13.0 \n10 AA             -2               8.59\n# ℹ 336,766 more rows\n\n\nCeci peut permettre, par exemple, de déterminer si un retard donné est supérieur ou inférieur au retard médian de la compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(\n      median_delay = median(dep_delay, na.rm = TRUE),\n      delay_carrier = ifelse(\n          dep_delay &gt; median_delay,\n          \"Supérieur\",\n          \"Inférieur ou égal\"\n      )\n  ) %&gt;%\n  select(dep_delay, median_delay, delay_carrier)\n\nAdding missing grouping variables: `carrier`\n\n\n# A tibble: 336,776 × 4\n# Groups:   carrier [16]\n   carrier dep_delay median_delay delay_carrier    \n   &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;            \n 1 UA              2            0 Supérieur        \n 2 UA              4            0 Supérieur        \n 3 AA              2           -3 Supérieur        \n 4 B6             -1           -1 Inférieur ou égal\n 5 DL             -6           -2 Inférieur ou égal\n 6 UA             -4            0 Inférieur ou égal\n 7 B6             -5           -1 Inférieur ou égal\n 8 EV             -3           -1 Inférieur ou égal\n 9 B6             -3           -1 Inférieur ou égal\n10 AA             -2           -3 Supérieur        \n# ℹ 336,766 more rows\n\n\ngroup_by peut aussi être utile avec filter, par exemple pour sélectionner pour chaque mois les vols avec un retard au départ plus élevé que le retard moyen ce mois-ci.\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  filter(dep_delay &gt;= mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 78,164 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      632            608        24      740            728\n 4  2013     1     1      732            645        47     1011            941\n 5  2013     1     1      743            730        13     1107           1100\n 6  2013     1     1      743            730        13     1059           1056\n 7  2013     1     1      749            710        39      939            850\n 8  2013     1     1      811            630       101     1047            830\n 9  2013     1     1      826            715        71     1136           1045\n10  2013     1     1      848           1835       853     1001           1950\n# ℹ 78,154 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAttention : la clause group_by marche pour les verbes déjà vus précédemment, sauf pour arrange, qui par défaut trie la table sans tenir compte des groupes. Pour obtenir un tri par groupe, il faut lui ajouter l’argument .by_group = TRUE.\n\n\nOn peut voir la différence en comparant les deux résultats suivants :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay))\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay), .by_group = TRUE)\n\n# A tibble: 336,776 × 22\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     1    10     1121           1635      1126     1239           1810\n 3  2013     1     1      848           1835       853     1001           1950\n 4  2013     1    13     1809            810       599     2054           1042\n 5  2013     1    16     1622            800       502     1911           1054\n 6  2013     1    23     1551            753       478     1812           1006\n 7  2013     1    10     1525            900       385     1713           1039\n 8  2013     1     1     2343           1724       379      314           1938\n 9  2013     1     2     2131           1512       379     2340           1741\n10  2013     1     7     2021           1415       366     2332           1724\n# ℹ 336,766 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\nsummarise permet d’agréger les lignes du tableau en effectuant une opération “résumée” sur une ou plusieurs colonnes. Par exemple, si on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights :\n\nflights %&gt;%\n  summarise(\n      retard_dep = mean(dep_delay, na.rm = TRUE),\n      retard_arr = mean(arr_delay, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 2\n  retard_dep retard_arr\n       &lt;dbl&gt;      &lt;dbl&gt;\n1       12.6       6.90\n\n\nCette fonction est en général utilisée avec group_by, puisqu’elle permet du coup d’agréger et résumer les lignes du tableau groupe par groupe. Si on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  summarise(\n      max_delay = max(dep_delay, na.rm = TRUE),\n      min_delay = min(dep_delay, na.rm = TRUE),\n      mean_delay = mean(dep_delay, na.rm = TRUE)\n  )\n\n# A tibble: 12 × 4\n   month max_delay min_delay mean_delay\n   &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n 1     1      1301       -30      10.0 \n 2     2       853       -33      10.8 \n 3     3       911       -25      13.2 \n 4     4       960       -21      13.9 \n 5     5       878       -24      13.0 \n 6     6      1137       -21      20.8 \n 7     7      1005       -22      21.7 \n 8     8       520       -26      12.6 \n 9     9      1014       -24       6.72\n10    10       702       -25       6.24\n11    11       798       -32       5.44\n12    12       896       -43      16.6 \n\n\nsummarise dispose d’un opérateur spécial, n(), qui retourne le nombre de lignes du groupe. Ainsi si on veut le nombre de vols par destination, on peut utiliser :\n\nflights %&gt;%\n  group_by(dest) %&gt;%\n  summarise(nb = n())\n\n# A tibble: 105 × 2\n   dest     nb\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\nn() peut aussi être utilisée avec filter et mutate.\nÀ noter que quand on veut compter le nombre de lignes par groupe, il est plus simple d’utiliser directement la fonction count. Ainsi le code suivant est identique au précédent :\n\nflights %&gt;%\n  count(dest)\n\n# A tibble: 105 × 2\n   dest      n\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\n\n\n\nOn peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du group_by. Le pipeline suivant calcule le retard moyen au départ pour chaque mois et pour chaque destination, et trie le résultat par retard décroissant :\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  arrange(desc(retard_moyen))\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,113 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1    12 BZN           75  \n 2     7 TUL           72.6\n 3     3 DSM           71.0\n 4     7 CAE           69.4\n 5    11 SBN           67.5\n 6     7 BHM           64.6\n 7     7 TYS           60.6\n 8     6 BHM           57.2\n 9     1 TUL           55.2\n10     1 SAV           54.8\n# ℹ 1,103 more rows\n\n\nOn peut également utiliser count sur plusieurs variables. Les commandes suivantes comptent le nombre de vols pour chaque couple aéroport de départ / aéroport d’arrivée, et trie le résultat par nombre de vols décroissant. Ici la colonne qui contient le nombre de vols, créée par count, s’appelle n par défaut :\n\nflights %&gt;%\n  count(origin, dest) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 224 × 3\n   origin dest      n\n   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n 1 JFK    LAX   11262\n 2 LGA    ATL   10263\n 3 LGA    ORD    8857\n 4 JFK    SFO    8204\n 5 LGA    CLT    6168\n 6 EWR    ORD    6100\n 7 JFK    BOS    5898\n 8 LGA    MIA    5781\n 9 JFK    MCO    5464\n10 EWR    BOS    5327\n# ℹ 214 more rows\n\n\nOn peut utiliser plusieurs opérations de groupage dans le même pipeline. Ainsi, si on souhaite déterminer le couple aéroport de départ / aéroport d’arrivée ayant le retard moyen au départ le plus élevé pour chaque mois de l’année, on devra procéder en deux étapes :\n\nd’abord grouper selon mois, aéroports d’origine et d’arrivée pour calculer le retard moyen\npuis grouper uniquement selon le mois pour sélectionner le mois avec le retard moyen maximal.\n\nAu final, on obtient le code suivant :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  group_by(month) %&gt;%\n  slice_max(retard_moyen)\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 12 × 4\n# Groups:   month [12]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    TUL           55.2\n 2     2 EWR    DSM           48.6\n 3     3 EWR    DSM           71.0\n 4     4 EWR    OKC           47.0\n 5     5 EWR    TYS           60.6\n 6     6 EWR    TYS           68.2\n 7     7 EWR    CAE           81.5\n 8     8 LGA    GSO           50.1\n 9     9 LGA    MSN           24.7\n10    10 EWR    CAE           50.1\n11    11 LGA    SBN           67.5\n12    12 EWR    BZN           75  \n\n\n\n\n\nLorsqu’on effectue un group_by suivi d’un summarise, le tableau résultat est automatiquement dégroupé de la dernière variable de regroupement. Ainsi le tableau généré par le code suivant est seulement groupé par month et origin :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE))\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 2,313 × 4\n# Groups:   month, origin [36]\n   month origin dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n 1     1 EWR    ALB          41.4 \n 2     1 EWR    ATL           8.07\n 3     1 EWR    AUS           6.67\n 4     1 EWR    AVL          25.5 \n 5     1 EWR    BDL          21.1 \n 6     1 EWR    BNA          16.3 \n 7     1 EWR    BOS           8.99\n 8     1 EWR    BQN          12.3 \n 9     1 EWR    BTV          20.5 \n10     1 EWR    BUF          23.1 \n# ℹ 2,303 more rows\n\n\ndplyr nous le signale d’ailleurs via un message d’avertissement : summarise() has grouped output by 'month', 'origin'.\nCe dégroupage progressif peut permettre “d’enchaîner” les opérations groupées. Dans l’exemple suivant on calcule le retard moyen au départ par destination et on conserve les trois retards les plus importants pour chaque mois.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 36 × 3\n# Groups:   month [12]\n   month dest  retard_moyen\n   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1     1 TUL           55.2\n 2     1 SAV           54.8\n 3     1 DSM           42.2\n 4     2 DSM           48.6\n 5     2 TUL           34.2\n 6     2 GSP           32.4\n 7     3 DSM           71.0\n 8     3 PVD           47.5\n 9     3 CAE           46.9\n10     4 OKC           47.0\n# ℹ 26 more rows\n\n\nOn peut à tout moment “dégrouper” un tableau à l’aide de ungroup. C’est nécessaire, dans l’exemple précédent, si on veut seulement récupérer les trois retards les plus importants pour l’ensemble des couples mois / destination.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  slice_max(retard_moyen, n = 3)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 3 × 3\n  month dest  retard_moyen\n  &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n1    12 BZN           75  \n2     7 TUL           72.6\n3     3 DSM           71.0\n\n\nOn peut aussi spécifier précisément le comportement de dégroupage de summarise en lui fournissant un argument supplémentaire .groups qui peut prendre notamment les valeurs suivantes :\n\n\"drop_last\" : dégroupe seulement de la dernière variable de groupage\n\"drop\" : dégroupe totalement le tableau résultat (équivaut à l’application d’un ungroup)\n\"keep\" : conserve toutes les variables de groupage\n\nCe concept de dégroupage successif peut être un peu déroutant de prime abord. Il est donc utile de faire attention aux avertissements affichés par ces opérations, et il ne faut pas hésiter à ajouter un ungroup en fin de pipeline si on sait qu’on ne souhaite pas utiliser les groupes encore existants par la suite.\nÀ noter que la fonction count, de son côté, renvoie un tableau non groupé.\n\nflights %&gt;%\n  count(month, dest)\n\n# A tibble: 1,113 × 3\n   month dest      n\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n 1     1 ALB      64\n 2     1 ATL    1396\n 3     1 AUS     169\n 4     1 AVL       2\n 5     1 BDL      37\n 6     1 BHM      25\n 7     1 BNA     399\n 8     1 BOS    1245\n 9     1 BQN      93\n10     1 BTV     223\n# ℹ 1,103 more rows"
  },
  {
    "objectID": "SFC1018_Manipulation_R.html#autres-fonctions-utiles",
    "href": "SFC1018_Manipulation_R.html#autres-fonctions-utiles",
    "title": "Manipulation de données",
    "section": "",
    "text": "dplyr contient beaucoup d’autres fonctions utiles pour la manipulation de données.\n\n\nCe verbe permet de sélectionner aléatoirement un nombre de lignes (avec l’argument n) ou une fraction des lignes (avec l’argument prop) d’un tableau.\nAinsi si on veut choisir 5 lignes au hasard dans le tableau airports :\n\nairports %&gt;% slice_sample(n = 5)\n\n# A tibble: 5 × 8\n  faa   name                               lat    lon   alt    tz dst   tzone   \n  &lt;chr&gt; &lt;chr&gt;                            &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   \n1 SME   Lake Cumberland Regional Airport  37.1  -84.6   927    -5 A     America…\n2 CVX   Charlevoix Municipal Airport      45.3  -85.3   669    -5 A     America…\n3 KKH   Kongiganak Airport                60.0 -163.     30    -9 A     America…\n4 MCI   Kansas City Intl                  39.3  -94.7  1026    -6 A     America…\n5 DET   Coleman A Young Muni              42.4  -83.0   626    -5 A     America…\n\n\nSi on veut tirer au hasard 10% des lignes de flights :\n\nflights %&gt;% slice_sample(prop = 0.1)\n\n# A tibble: 33,677 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     2    10      746            745         1     1211           1234\n 2  2013    12    11     1047           1047         0     1248           1245\n 3  2013     3     8       NA           1729        NA       NA           2049\n 4  2013     2    25     1249           1300       -11     1442           1450\n 5  2013    10     4      803            810        -7     1052           1119\n 6  2013    10    10     1515           1454        21     1716           1712\n 7  2013    11    17     1150           1151        -1     1514           1459\n 8  2013    10    24      634            637        -3      922            923\n 9  2013     3    16      825            830        -5     1041           1106\n10  2013     7    14      112           2359        73      447            340\n# ℹ 33,667 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nCes fonctions sont utiles notamment pour faire de “l’échantillonnage” en tirant au hasard un certain nombre d’observations du tableau.\n\n\n\nlead et lag permettent de décaler les observations d’une variable d’un cran vers l’arrière (pour lead) ou vers l’avant (pour lag).\n\nlead(1:5)\n\n[1]  2  3  4  5 NA\n\nlag(1:5)\n\n[1] NA  1  2  3  4\n\n\nCeci peut être utile pour des données de type “séries temporelles”. Par exemple, on peut facilement calculer l’écart entre le retard au départ de chaque vol et celui du vol précédent :\n\nflights %&gt;%\n  mutate(\n      dep_delay_prev = lag(dep_delay),\n      dep_delay_diff = dep_delay - dep_delay_prev\n  ) %&gt;%\n  select(dep_delay_prev, dep_delay, dep_delay_diff)\n\n# A tibble: 336,776 × 3\n   dep_delay_prev dep_delay dep_delay_diff\n            &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;\n 1             NA         2             NA\n 2              2         4              2\n 3              4         2             -2\n 4              2        -1             -3\n 5             -1        -6             -5\n 6             -6        -4              2\n 7             -4        -5             -1\n 8             -5        -3              2\n 9             -3        -3              0\n10             -3        -2              1\n# ℹ 336,766 more rows\n\n\n\n\n\ndistinct filtre les lignes du tableau pour ne conserver que les lignes distinctes, en supprimant toutes les lignes en double.\n\nflights %&gt;%\n  select(day, month) %&gt;%\n  distinct()\n\n# A tibble: 365 × 2\n     day month\n   &lt;int&gt; &lt;int&gt;\n 1     1     1\n 2     2     1\n 3     3     1\n 4     4     1\n 5     5     1\n 6     6     1\n 7     7     1\n 8     8     1\n 9     9     1\n10    10     1\n# ℹ 355 more rows\n\n\nOn peut lui spécifier une liste de variables : dans ce cas, pour toutes les observations ayant des valeurs identiques pour les variables en question, distinct ne conservera que la première d’entre elles.\n\nflights %&gt;%\n  distinct(month, day)\n\n# A tibble: 365 × 2\n   month   day\n   &lt;int&gt; &lt;int&gt;\n 1     1     1\n 2     1     2\n 3     1     3\n 4     1     4\n 5     1     5\n 6     1     6\n 7     1     7\n 8     1     8\n 9     1     9\n10     1    10\n# ℹ 355 more rows\n\n\nL’option .keep_all permet, dans l’opération précédente, de conserver l’ensemble des colonnes du tableau :\n\nflights %&gt;%\n  distinct(month, day, .keep_all = TRUE)\n\n# A tibble: 365 × 22\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     2       42           2359        43      518            442\n 3  2013     1     3       32           2359        33      504            442\n 4  2013     1     4       25           2359        26      505            442\n 5  2013     1     5       14           2359        15      503            445\n 6  2013     1     6       16           2359        17      451            442\n 7  2013     1     7       49           2359        50      531            444\n 8  2013     1     8      454            500        -6      625            648\n 9  2013     1     9        2           2359         3      432            444\n10  2013     1    10        3           2359         4      426            437\n# ℹ 355 more rows\n# ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nLa fonction n_distinct, elle, renvoie le nombre de valeurs distinctes d’un vecteur. On peut notamment l’utiliser dans un summarise.\nDans l’exemple qui suit on calcule, pour les trois aéroports de départ de la table flights le nombre de valeurs distinctes de l’aéroport d’arrivée :\n\nflights %&gt;%\n  group_by(origin) %&gt;%\n  summarise(n_dest = n_distinct(dest))\n\n# A tibble: 3 × 2\n  origin n_dest\n  &lt;chr&gt;   &lt;int&gt;\n1 EWR        86\n2 JFK        70\n3 LGA        68\n\n\n\n\n\nrelocate peut être utilisé pour réordonner les colonnes d’une table. Par défaut, si on lui passe un ou plusieurs noms de colonnes, relocate les place en début de tableau.\n\nairports %&gt;% relocate(lat, lon)\n\n# A tibble: 1,458 × 8\n     lat    lon faa   name                             alt    tz dst   tzone    \n   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n 1  41.1  -80.6 04G   Lansdowne Airport               1044    -5 A     America/…\n 2  32.5  -85.7 06A   Moton Field Municipal Airport    264    -6 A     America/…\n 3  42.0  -88.1 06C   Schaumburg Regional              801    -6 A     America/…\n 4  41.4  -74.4 06N   Randall Airport                  523    -5 A     America/…\n 5  31.1  -81.4 09J   Jekyll Island Airport             11    -5 A     America/…\n 6  36.4  -82.2 0A9   Elizabethton Municipal Airport  1593    -5 A     America/…\n 7  41.5  -84.5 0G6   Williams County Airport          730    -5 A     America/…\n 8  42.9  -76.8 0G7   Finger Lakes Regional Airport    492    -5 A     America/…\n 9  39.8  -76.6 0P2   Shoestring Aviation Airfield    1000    -5 U     America/…\n10  48.1 -123.  0S9   Jefferson County Intl            108    -8 A     America/…\n# ℹ 1,448 more rows\n\n\nLes arguments supplémentaires .before et .after permettent de préciser à quel endroit déplacer la ou les colonnes indiquées.\n\nairports %&gt;% relocate(starts_with('tz'), .after = name)\n\n# A tibble: 1,458 × 8\n   faa   name                              tz tzone       lat    lon   alt dst  \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n 1 04G   Lansdowne Airport                 -5 America/…  41.1  -80.6  1044 A    \n 2 06A   Moton Field Municipal Airport     -6 America/…  32.5  -85.7   264 A    \n 3 06C   Schaumburg Regional               -6 America/…  42.0  -88.1   801 A    \n 4 06N   Randall Airport                   -5 America/…  41.4  -74.4   523 A    \n 5 09J   Jekyll Island Airport             -5 America/…  31.1  -81.4    11 A    \n 6 0A9   Elizabethton Municipal Airport    -5 America/…  36.4  -82.2  1593 A    \n 7 0G6   Williams County Airport           -5 America/…  41.5  -84.5   730 A    \n 8 0G7   Finger Lakes Regional Airport     -5 America/…  42.9  -76.8   492 A    \n 9 0P2   Shoestring Aviation Airfield      -5 America/…  39.8  -76.6  1000 U    \n10 0S9   Jefferson County Intl             -8 America/…  48.1 -123.    108 A    \n# ℹ 1,448 more rows"
  },
  {
    "objectID": "SFC1018_Manipulation_R.html#tables-multiples",
    "href": "SFC1018_Manipulation_R.html#tables-multiples",
    "title": "Manipulation de données",
    "section": "",
    "text": "Le jeu de données nycflights13 est un exemple de données réparties en plusieurs tables. Ici on en a trois : les informations sur les vols dans flights, celles sur les aéroports dans airports et celles sur les compagnies aériennes dans airlines.\ndplyr propose différentes fonctions permettant de travailler avec des données structurées de cette manière.\n\n\nLes fonctions bind_rows et bind_cols permettent d’ajouter des lignes (respectivement des colonnes) à une table à partir d’une ou plusieurs autres tables.\nL’exemple suivant (certes très artificiel) montre l’utilisation de bind_rows. On commence par créer trois tableaux t1, t2 et t3 :\n\nt1 &lt;- airports %&gt;%\n  select(faa, name, lat, lon) %&gt;%\n  slice(1:2)\nt1\n\n# A tibble: 2 × 4\n  faa   name                            lat   lon\n  &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt;\n1 04G   Lansdowne Airport              41.1 -80.6\n2 06A   Moton Field Municipal Airport  32.5 -85.7\n\n\n\nt2 &lt;- airports %&gt;%\n  select(faa, name, lat, lon) %&gt;%\n  slice(5:6)\n\nt2\n\n# A tibble: 2 × 4\n  faa   name                             lat   lon\n  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n1 09J   Jekyll Island Airport           31.1 -81.4\n2 0A9   Elizabethton Municipal Airport  36.4 -82.2\n\n\n\nt3 &lt;- airports %&gt;%\n  select(faa, name) %&gt;%\n  slice(100:101)\nt3\n\n# A tibble: 2 × 2\n  faa   name             \n  &lt;chr&gt; &lt;chr&gt;            \n1 ADW   Andrews Afb      \n2 AET   Allakaket Airport\n\n\nOn concaténe ensuite les trois tables avec bind_rows :\n\nbind_rows(t1, t2, t3)\n\n# A tibble: 6 × 4\n  faa   name                             lat   lon\n  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n1 04G   Lansdowne Airport               41.1 -80.6\n2 06A   Moton Field Municipal Airport   32.5 -85.7\n3 09J   Jekyll Island Airport           31.1 -81.4\n4 0A9   Elizabethton Municipal Airport  36.4 -82.2\n5 ADW   Andrews Afb                     NA    NA  \n6 AET   Allakaket Airport               NA    NA  \n\n\nOn remarquera que si des colonnes sont manquantes pour certaines tables, comme les colonnes lat et lon de t3, des NA sont automatiquement insérées.\nIl peut être utile, quand on concatène des lignes, de garder une trace du tableau d’origine de chacune des lignes dans le tableau final. C’est possible grâce à l’argument .id de bind_rows. On passe à cet argument le nom d’une colonne qui contiendra l’indicateur d’origine des lignes :\n\nbind_rows(t1, t2, t3, .id = \"source\")\n\n# A tibble: 6 × 5\n  source faa   name                             lat   lon\n  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n1 1      04G   Lansdowne Airport               41.1 -80.6\n2 1      06A   Moton Field Municipal Airport   32.5 -85.7\n3 2      09J   Jekyll Island Airport           31.1 -81.4\n4 2      0A9   Elizabethton Municipal Airport  36.4 -82.2\n5 3      ADW   Andrews Afb                     NA    NA  \n6 3      AET   Allakaket Airport               NA    NA  \n\n\nPar défaut la colonne .id ne contient qu’un nombre, différent pour chaque tableau. On peut lui spécifier des valeurs plus explicites en “nommant” les tables dans bind_rows de la manière suivante :\n\nbind_rows(table1 = t1, table2 = t2, table3 = t3, .id = \"source\")\n\n# A tibble: 6 × 5\n  source faa   name                             lat   lon\n  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n1 table1 04G   Lansdowne Airport               41.1 -80.6\n2 table1 06A   Moton Field Municipal Airport   32.5 -85.7\n3 table2 09J   Jekyll Island Airport           31.1 -81.4\n4 table2 0A9   Elizabethton Municipal Airport  36.4 -82.2\n5 table3 ADW   Andrews Afb                     NA    NA  \n6 table3 AET   Allakaket Airport               NA    NA  \n\n\nbind_cols permet de concaténer des colonnes et fonctionne de manière similaire :\n\nt1 &lt;- flights %&gt;% slice(1:5) %&gt;% select(dep_delay, dep_time)\nt2 &lt;- flights %&gt;% slice(1:5) %&gt;% select(origin, dest)\nt3 &lt;- flights %&gt;% slice(1:5) %&gt;% select(arr_delay, arr_time)\nbind_cols(t1, t2, t3)\n\n# A tibble: 5 × 6\n  dep_delay dep_time origin dest  arr_delay arr_time\n      &lt;dbl&gt;    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;    &lt;int&gt;\n1         2      517 EWR    IAH          11      830\n2         4      533 LGA    IAH          20      850\n3         2      542 JFK    MIA          33      923\n4        -1      544 JFK    BQN         -18     1004\n5        -6      554 LGA    ATL         -25      812\n\n\nÀ noter que bind_cols associe les lignes uniquement par position. Les lignes des différents tableaux associés doivent donc correspondre (et leur nombre doit être identique). Pour associer des tables par valeur, on doit utiliser des jointures.\n\n\n\n\n\nTrès souvent, les données relatives à une analyse sont réparties dans plusieurs tables différentes. Dans notre exemple, on peut voir que la table flights contient le code de la compagnie aérienne du vol dans la variable carrier :\n\nflights %&gt;% select(carrier)\n\n# A tibble: 336,776 × 1\n   carrier\n   &lt;chr&gt;  \n 1 UA     \n 2 UA     \n 3 AA     \n 4 B6     \n 5 DL     \n 6 UA     \n 7 B6     \n 8 EV     \n 9 B6     \n10 AA     \n# ℹ 336,766 more rows\n\n\nEt que par ailleurs la table airlines contient une information supplémentaire relative à ces compagnies, à savoir le nom complet.\n\nairlines\n\n# A tibble: 16 × 2\n   carrier name                       \n   &lt;chr&gt;   &lt;chr&gt;                      \n 1 9E      Endeavor Air Inc.          \n 2 AA      American Airlines Inc.     \n 3 AS      Alaska Airlines Inc.       \n 4 B6      JetBlue Airways            \n 5 DL      Delta Air Lines Inc.       \n 6 EV      ExpressJet Airlines Inc.   \n 7 F9      Frontier Airlines Inc.     \n 8 FL      AirTran Airways Corporation\n 9 HA      Hawaiian Airlines Inc.     \n10 MQ      Envoy Air                  \n11 OO      SkyWest Airlines Inc.      \n12 UA      United Air Lines Inc.      \n13 US      US Airways Inc.            \n14 VX      Virgin America             \n15 WN      Southwest Airlines Co.     \n16 YV      Mesa Airlines Inc.         \n\n\nIl est donc naturel de vouloir associer les deux, ici pour ajouter les noms complets des compagnies à la table flights. Pour cela on va effectuer une jointure : les lignes d’une table seront associées à une autre en se basant non pas sur leur position, mais sur les valeurs d’une ou plusieurs colonnes. Ces colonnes sont appelées des clés.\nPour faire une jointure de ce type, on va utiliser la fonction left_join :\n\nleft_join(flights, airlines)\n\nPour faciliter la lecture, on va afficher seulement certaines colonnes du résultat :\n\nleft_join(flights, airlines) %&gt;%\n  select(month, day, carrier, name)\n\nJoining with `by = join_by(carrier)`\n\n\n# A tibble: 336,776 × 4\n   month   day carrier name                    \n   &lt;int&gt; &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;                   \n 1     1     1 UA      United Air Lines Inc.   \n 2     1     1 UA      United Air Lines Inc.   \n 3     1     1 AA      American Airlines Inc.  \n 4     1     1 B6      JetBlue Airways         \n 5     1     1 DL      Delta Air Lines Inc.    \n 6     1     1 UA      United Air Lines Inc.   \n 7     1     1 B6      JetBlue Airways         \n 8     1     1 EV      ExpressJet Airlines Inc.\n 9     1     1 B6      JetBlue Airways         \n10     1     1 AA      American Airlines Inc.  \n# ℹ 336,766 more rows\n\n\nOn voit que la table résultat est bien la fusion des deux tables d’origine selon les valeurs des deux colonnes clés carrier. On est parti de la table flights, et pour chaque ligne de celle-ci on a ajouté les colonnes de airlines pour lesquelles la valeur de carrier est la même. On a donc bien une nouvelle colonne name dans notre table résultat, avec le nom complet de la compagnie aérienne.\n\n\n\n\n\n\nNote\n\n\n\nÀ noter qu’on peut tout à fait utiliser le pipe avec les fonctions de jointure :\nflights %&gt;% left_join(airlines).\n\n\nNous sommes ici dans le cas le plus simple concernant les clés de jointure : les deux clés sont uniques et portent le même nom dans les deux tables. Par défaut, si on ne lui spécifie pas explicitement les clés, dplyr fusionne en utilisant l’ensemble des colonnes communes aux deux tables. On peut d’ailleurs voir dans cet exemple qu’un message a été affiché précisant que la jointure s’est bien faite sur la variable carrier.\n\n\n\nLa table airports, contient des informations supplémentaires sur les aéroports : nom complet, altitude, position géographique, etc. Chaque aéroport est identifié par un code contenu dans la colonne faa.\nSi on regarde la table flights, on voit que le code d’identification des aéroports apparaît à deux endroits différents : pour l’aéroport de départ dans la colonne origin, et pour celui d’arrivée dans la colonne dest. On a donc deux clés de jointure possibles, et qui portent un nom différent de la clé de airports.\nOn va commencer par fusionner les données concernant l’aéroport de départ. Pour simplifier l’affichage des résultats, on va se contenter d’un sous-ensemble des deux tables :\n\nflights_ex &lt;- flights %&gt;% select(month, day, origin, dest)\nairports_ex &lt;- airports %&gt;% select(faa, alt, name)\n\nSi on se contente d’un left_join comme à l’étape précédente, on obtient un message d’erreur car aucune colonne commune ne peut être identifiée comme clé de jointure :\n\nflights_ex %&gt;% left_join(airports_ex)\n\nError in `left_join()`:\n! `by` must be supplied when `x` and `y` have no common variables.\nℹ Use `cross_join()` to perform a cross-join.\n\n\nOn doit donc spécifier explicitement les clés avec l’argument by de left_join. Ici la clé est nommée origin dans la première table, et faa dans la seconde. La syntaxe est donc la suivante :\n\nflights_ex %&gt;% \n  left_join(airports_ex, by = c(\"origin\" = \"faa\"))\n\n# A tibble: 336,776 × 6\n   month   day origin dest    alt name               \n   &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;              \n 1     1     1 EWR    IAH      18 Newark Liberty Intl\n 2     1     1 LGA    IAH      22 La Guardia         \n 3     1     1 JFK    MIA      13 John F Kennedy Intl\n 4     1     1 JFK    BQN      13 John F Kennedy Intl\n 5     1     1 LGA    ATL      22 La Guardia         \n 6     1     1 EWR    ORD      18 Newark Liberty Intl\n 7     1     1 EWR    FLL      18 Newark Liberty Intl\n 8     1     1 LGA    IAD      22 La Guardia         \n 9     1     1 JFK    MCO      13 John F Kennedy Intl\n10     1     1 LGA    ORD      22 La Guardia         \n# ℹ 336,766 more rows\n\n\nOn constate que les deux nouvelles colonnes name et alt contiennent bien les données correspondant à l’aéroport de départ.\nOn va stocker le résultat de cette jointure dans la table flights_ex :\n\nflights_ex &lt;- flights_ex %&gt;%\n  left_join(airports_ex, by = c(\"origin\" = \"faa\"))\n\nSupposons qu’on souhaite maintenant fusionner à nouveau les informations de la table airports, mais cette fois pour les aéroports d’arrivée de notre nouvelle table flights_ex. Les deux clés sont donc désormais dest dans la première table, et faa dans la deuxième. La syntaxe est donc la suivante :\n\nflights_ex %&gt;%\n  left_join(airports_ex, by = c(\"dest\" = \"faa\"))\n\n# A tibble: 336,776 × 8\n   month   day origin dest  alt.x name.x              alt.y name.y              \n   &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;               \n 1     1     1 EWR    IAH      18 Newark Liberty Intl    97 George Bush Interco…\n 2     1     1 LGA    IAH      22 La Guardia             97 George Bush Interco…\n 3     1     1 JFK    MIA      13 John F Kennedy Intl     8 Miami Intl          \n 4     1     1 JFK    BQN      13 John F Kennedy Intl    NA &lt;NA&gt;                \n 5     1     1 LGA    ATL      22 La Guardia           1026 Hartsfield Jackson …\n 6     1     1 EWR    ORD      18 Newark Liberty Intl   668 Chicago Ohare Intl  \n 7     1     1 EWR    FLL      18 Newark Liberty Intl     9 Fort Lauderdale Hol…\n 8     1     1 LGA    IAD      22 La Guardia            313 Washington Dulles I…\n 9     1     1 JFK    MCO      13 John F Kennedy Intl    96 Orlando Intl        \n10     1     1 LGA    ORD      22 La Guardia            668 Chicago Ohare Intl  \n# ℹ 336,766 more rows\n\n\nCela fonctionne, les informations de l’aéroport d’arrivée ont bien été ajoutées, mais on constate que les colonnes ont été renommées. En effet, ici les deux tables fusionnées contenaient toutes les deux des colonnes name et alt. Comme on ne peut pas avoir deux colonnes avec le même nom dans un tableau, dplyr a renommé les colonnes de la première table en name.x et alt.x, et celles de la deuxième en name.y et alt.y.\nC’est pratique, mais pas forcément très parlant. On pourrait renommer manuellement les colonnes avec rename avant de faire la jointure pour avoir des intitulés plus explicites, mais on peut aussi utiliser l’argument suffix de left_join, qui permet d’indiquer les suffixes à ajouter aux colonnes.\n\nflights_ex %&gt;%\n  left_join(\n    airports_ex,\n    by = c(\"dest\" = \"faa\"),\n    suffix = c(\"_depart\", \"_arrivee\")\n  )\n\n# A tibble: 336,776 × 8\n   month   day origin dest  alt_depart name_depart      alt_arrivee name_arrivee\n   &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;                  &lt;dbl&gt; &lt;chr&gt;       \n 1     1     1 EWR    IAH           18 Newark Liberty …          97 George Bush…\n 2     1     1 LGA    IAH           22 La Guardia                97 George Bush…\n 3     1     1 JFK    MIA           13 John F Kennedy …           8 Miami Intl  \n 4     1     1 JFK    BQN           13 John F Kennedy …          NA &lt;NA&gt;        \n 5     1     1 LGA    ATL           22 La Guardia              1026 Hartsfield …\n 6     1     1 EWR    ORD           18 Newark Liberty …         668 Chicago Oha…\n 7     1     1 EWR    FLL           18 Newark Liberty …           9 Fort Lauder…\n 8     1     1 LGA    IAD           22 La Guardia               313 Washington …\n 9     1     1 JFK    MCO           13 John F Kennedy …          96 Orlando Intl\n10     1     1 LGA    ORD           22 La Guardia               668 Chicago Oha…\n# ℹ 336,766 more rows\n\n\nOn obtient ainsi directement des noms de colonnes nettement plus clairs.\n\n\n\n\nJusqu’à présent nous avons utilisé la fonction left_join, mais il existe plusieurs types de jointures.\nPartons de deux tables d’exemple, personnes et voitures :\n\npersonnes &lt;- tibble(\n    nom = c(\"Sylvie\", \"Sylvie\", \"Monique\", \"Gunter\", \"Rayan\", \"Rayan\"),\n    voiture = c(\"Twingo\", \"Ferrari\", \"Scenic\", \"Lada\", \"Twingo\", \"Clio\")\n)\n\n\n\n\n\n\nnom\nvoiture\n\n\n\n\nSylvie\nTwingo\n\n\nSylvie\nFerrari\n\n\nMonique\nScenic\n\n\nGunter\nLada\n\n\nRayan\nTwingo\n\n\nRayan\nClio\n\n\n\n\n\n\nvoitures &lt;- tibble(\n    voiture = c(\"Twingo\", \"Ferrari\", \"Clio\", \"Lada\", \"208\"),\n    vitesse = c(\"140\", \"280\", \"160\", \"85\", \"160\")\n)\n\n\n\n\n\n\nvoiture\nvitesse\n\n\n\n\nTwingo\n140\n\n\nFerrari\n280\n\n\nClio\n160\n\n\nLada\n85\n\n\n208\n160\n\n\n\n\n\n\n\nSi on fait un left_join de voitures sur personnes :\n\npersonnes %&gt;% left_join(voitures)\n\n\n\nJoining with `by = join_by(voiture)`\n\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nMonique\nScenic\nNA\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\n\n\n\nOn voit que chaque ligne de personnes est bien présente, et qu’on lui a ajouté une ligne de voitures correspondante si elle existe. Dans le cas du Scenic, il n’y a avait pas de ligne dans voitures, donc vitesse a été mise à NA. Dans le cas de 208, présente dans voitures mais pas dans personnes, la ligne n’apparaît pas.\nSi on fait un left_join cette fois de personnes sur voitures, c’est l’inverse :\n\nvoitures %&gt;% left_join(personnes)\n\n\n\nJoining with `by = join_by(voiture)`\n\n\n\n\n\nvoiture\nvitesse\nnom\n\n\n\n\nTwingo\n140\nSylvie\n\n\nTwingo\n140\nRayan\n\n\nFerrari\n280\nSylvie\n\n\nClio\n160\nRayan\n\n\nLada\n85\nGunter\n\n\n208\n160\nNA\n\n\n\n\n\nLa ligne 208 est là, mais nom est à NA. Par contre Monique est absente. Et on remarquera que la ligne Twingo, présente deux fois dans personnes, a été dupliquée pour être associée aux deux lignes de données de Sylvie et Rayan.\nEn résumé, quand on fait un left_join(x, y), toutes les lignes de x sont présentes, et dupliquées si nécessaire quand elles apparaissent plusieurs fois dans y. Les lignes de y non présentes dans x disparaissent. Les lignes de x non présentes dans y se voient attribuer des NA pour les nouvelles colonnes.\nIntuitivement, on pourrait considérer que left_join(x, y) signifie “ramener l’information de la table y sur la table x”.\nEn général, left_join sera le type de jointures le plus fréquemment utilisé.\n\n\n\nLa jointure right_join est l’exacte symétrique de left_join, c’est-à dire que right_join(x, y) est équivalent à left_join(y, x) :\n\npersonnes %&gt;% right_join(voitures)\n\n\n\nJoining with `by = join_by(voiture)`\n\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\nNA\n208\n160\n\n\n\n\n\n\n\n\nDans le cas de inner_join(x, y), seules les lignes présentes à la fois dans x et y sont conservées (et si nécessaire dupliquées) dans la table résultat :\n\npersonnes %&gt;% inner_join(voitures)\n\n\n\nJoining with `by = join_by(voiture)`\n\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\n\n\n\nIci la ligne 208 est absente, ainsi que la ligne Monique, qui dans le cas d’un left_join avait été conservée et s’était vue attribuer une vitesse à NA.\n\n\n\nDans le cas de full_join(x, y), toutes les lignes de x et toutes les lignes de y sont conservées (avec des NA ajoutés si nécessaire) même si elles sont absentes de l’autre table :\n\npersonnes %&gt;% full_join(voitures)\n\n\n\nJoining with `by = join_by(voiture)`\n\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nMonique\nScenic\nNA\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\nNA\n208\n160"
  },
  {
    "objectID": "SFC1018_Manipulation_R.html#ressources",
    "href": "SFC1018_Manipulation_R.html#ressources",
    "title": "Manipulation de données",
    "section": "",
    "text": "Le livre R for data science, librement accessible en ligne, contient plusieurs chapitres très complets sur la manipulation des données, notamment :\n\nData transformation pour les manipulations\nRelational data pour les tables multiples\n\nLe site de l’extension comprend une liste des fonctions et les pages d’aide associées, mais aussi une introduction au package et plusieurs articles dont un spécifiquement sur les jointures.\nEnfin, une “antisèche” très synthétique est également accessible depuis RStudio, en allant dans le menu Help puis Cheatsheets et Data Transformation with dplyr."
  },
  {
    "objectID": "SFC1018_Manipulation_R.html#exercices",
    "href": "SFC1018_Manipulation_R.html#exercices",
    "title": "Manipulation de données",
    "section": "",
    "text": "On commence par charger les extensions et les données nécessaires.\n\nlibrary(tidyverse)\nlibrary(nycflights13)\ndata(flights)\ndata(airports)\ndata(airlines)\n\n\n\nExercice 1.1\nSélectionner la dixième ligne du tableau des aéroports (airports).\nSélectionner les 5 premières lignes de la table airlines.\nSélectionner l’aéroport avec l’altitude la plus basse.\nExercice 1.2\nSélectionnez les vols du mois de juillet (variable month).\nSélectionnez les vols avec un retard à l’arrivée (variable arr_delay) compris entre 5 et 15 minutes.\nSélectionnez les vols des compagnies Delta, United et American (codes DL, UA et AA de la variable carrier).\nExercice 1.3\nTriez la table flights par retard au départ décroissant.\nExercice 1.4\nSélectionnez les colonnes name, lat et lon de la table airports\nSélectionnez toutes les colonnes de la table airports sauf les colonnes tz et tzone\nSélectionnez toutes les colonnes de la table flights dont les noms se terminent par “delay”.\nDans la table airports, renommez la colonne alt en altitude et la colonne tzone en fuseau_horaire.\nExercice 1.5\nDans la table airports, la colonne alt contient l’altitude de l’aéroport en pieds. Créer une nouvelle variable alt_m contenant l’altitude en mètres (on convertit des pieds en mètres en les divisant par 3.2808). Sélectionner dans la table obtenue uniquement les deux colonnes alt et alt_m.\n\n\n\nExercice 2.1\nRéécrire le code de l’exercice précédent en utilisant le pipe %&gt;%.\nExercice 2.2\nEn utilisant le pipe, sélectionnez les vols à destination de San Francico (code SFO de la variable dest) et triez-les selon le retard au départ décroissant (variable dep_delay).\nExercice 2.3\nSélectionnez les vols des mois de septembre et octobre, conservez les colonnes dest et dep_delay, créez une nouvelle variable retard_h contenant le retard au départ en heures, et conservez uniquement les 5 lignes avec les plus grandes valeurs de retard_h.\n\n\n\nExercice 3.1\nAffichez le nombre de vols par mois.\nTriez la table résultat selon le nombre de vols croissant.\nExercice 3.2\nCalculer la distance moyenne des vols selon l’aéroport de départ (variable origin).\nExercice 3.3\nCalculer le nombre de vols à destination de Los Angeles (code LAX) pour chaque mois de l’année.\nExercice 3.4\nCalculer le nombre de vols selon le mois et la destination.\nNe conserver, pour chaque mois, que la destination avec le nombre maximal de vols.\nExercice 3.5\nCalculer le nombre de vols selon le mois. Ajouter une colonne comportant le pourcentage de vols annuels réalisés par mois.\nExercice 3.6\nCalculer, pour chaque aéroport de départ et de destination, la durée moyenne des vols (variable air_time). Pour chaque aéroport de départ, ne conserver que la destination avec la durée moyenne la plus longue.\n\n\n\nExercice 4.1\nFaire la jointure de la table airlines sur la table flights à l’aide de left_join.\nExercice 4.2\nÀ partir de la table résultat de l’exercice précédent, calculer le retard moyen au départ pour chaque compagnie, et trier selon ce retard décroissant.\nExercice 4.3\nFaire la jointure de la table airports sur la table flights en utilisant comme clé le code de l’aéroport de destination.\nÀ partir de cette table, afficher pour chaque mois le nom de l’aéroport de destination ayant eu le plus petit nombre de vol.\nExercice 4.4\nCréer une table indiquant, pour chaque vol, uniquement le nom de l’aéroport de départ et celui de l’aéroport d’arrivée."
  },
  {
    "objectID": "SFC1018_Manipulation_R.html#footnotes",
    "href": "SFC1018_Manipulation_R.html#footnotes",
    "title": "Manipulation de données",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nÀ noter que cette opération est un peu plus “fragile” que les autres, car si l’ordre des colonnes change elle peut renvoyer un résultat différent.↩︎\nIl est également possible de renommer des colonnes directement avec select, avec la même syntaxe que pour rename.↩︎\nLe pipe a été introduit à l’origine par l’extension magrittr, et repris par dplyr↩︎"
  }
]